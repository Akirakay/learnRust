## 3.1 生命周期

### 3.1.1 认识生命周期

生命周期，简而言之就是引用的有效作用域。

多数情况下编译器可以自动进行推导，用类型来类比下：

-   就像编译器大部分时候可以自动推导类型 <-> 一样，编译器大多数时候也可以自动推导生命周期
-   在多种类型存在时，编译器往往要求我们手动标明类型 <-> 当多个生命周期存在，且编译器无法推导出某个引用的生命周期时，就需要我们手动标明生命周期

#### 悬垂指针与生命周期

生命周期的主要作用是避免悬垂引用，它会导致程序引用了本不该引用的数据：

```rust
#![allow(unused)]
fn main() {
    {
        let r;

        {
            let x = 5;
            r = &x;
        }

        println!("r: {}", r);
    }
}
```

代码有几点值得注意:

-   `let r;` 的声明方式貌似存在使用 `null` 的风险，实际上，当我们不初始化它就使用时，编译器会给予报错
-   `r` 引用了内部花括号中的 `x` 变量，但是 `x` 会在内部花括号 `}` 处被释放，因此回到外部花括号后，`r` 会引用一个无效的 `x`

 `r` 就是一个悬垂指针，它引用了提前被释放的变量 `x`

#### 借用检查

为保证 Rust 的所有权和借用的正确性，Rust 使用了一个借用检查器(Borrow checker)来检查我们程序借用的正确性：

```txt
#![allow(unused)]
fn main() {
    {
        let r;                        // ---------+-- 'a
                                      //          |
        {                             //          |
                                      //          |
            let x = 5;                // -+-- 'b  |
            r = &x;                   //  |       |
        }                             // -+       |
                                      //          |
        println!("r: {}", r);         //          |
    }                                 // ---------+
}
```

编译器，Rust 会检查两个变量的生命周期，因为 `r` 的生命周期 `'a`  比 `x` 的生命周期 `'b` 要大，因此拒绝运行。

#### 函数中的生命周期

思考下面的例子：

```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
output:
error[E0106]: missing lifetime specifier
  --> src/main.rs:22:33
   |
22 | fn longest(x: &str, y: &str) -> &str {
   |               ----     ----     ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
   |
22 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
   |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
```

编译器无法知道该函数的返回值到底引用 `x` 还是 `y` ，**因为编译器需要知道这些，来确保函数调用后的引用生命周期分析**。

在存在多个引用时，编译器有时会无法自动推导生命周期，此时就需要我们手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查的分析。

#### 生命周期标注语法

>   生命周期标注并不会改变任何引用的实际作用域

语法：以 `'` 开头，名称往往是一个单独的小写字母。eg: 'a.

引用类型参数 -> 生命周期会位于引用符号 `&` 之后，并用一个空格隔开。 eg: `&'a i32`

```rust
&i32        // 一个引用
&'a i32     // 具有显式生命周期的引用
&'a mut i32 // 具有显式生命周期的可变引用
```

##### 函数签名中的生命周期标注

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

需要注意的点如下：

-   和泛型一样，使用生命周期参数，需要先声明 `<'a>`
-   `x`、`y` 和返回值至少活得和 `'a` 一样久(因为返回值要么是 `x`，要么是 `y`)

##### 深入思考生命周期标注

**函数的返回值如果是一个引用类型，那么它的生命周期只会来源于**：

-   函数参数的生命周期
-   函数体中某个新建引用的生命周期

若是后者情况，就是典型的悬垂引用场景：最好的办法就是返回内部字符串的所有权，然后把字符串的所有权转移给调用者。

对生命周期进行下总结：生命周期语法用来将函数的多个引用参数和返回值的作用域关联到一起，一旦关联到一起后，Rust 就拥有充分的信息来确保我们的操作是内存安全的。

#### 结构体中的生命周期

为结构体中每一项引用标注生命周期即可：

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

**结构体 `ImportantExcerpt` 所引用的字符串 `str` 必须比该结构体活得更久**

#### 生命周期消除

注意：

-   消除规则不是万能的，若编译器不能确定某件事是正确时，会直接判为不正确，那么你还是需要手动标注生命周期
-   **函数或者方法中，参数的生命周期被称为 `输入生命周期`，返回值的生命周期被称为 `输出生命周期`**

##### 三条消除规则

1.   **每一个引用参数都会获得独自的生命周期**
2.   **若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期**
3.   **若存在多个输入生命周期，且其中一个是 `&self` 或 `&mut self`，则 `&self` 的生命周期被赋给所有的输出生命周期**

#### 方法中的生命周期

为具有生命周期的结构体实现方法时，我们使用的语法跟泛型参数语法很相似：

```rust
#![allow(unused)]
fn main() {
    struct ImportantExcerpt<'a> {
        part: &'a str,
    }

    impl<'a> ImportantExcerpt<'a> {
        fn level(&self) -> i32 {
            3
        }
    }
}
```

#### 静态生命周期

Rust 中有一个非常特殊的生命周期，那就是 `'static`，拥有该生命周期的引用可以和整个程序活得一样久。

总结如下：

-   生命周期 `'static` 意味着能和程序活得一样久，例如字符串字面量和特征对象
-   实在遇到解决不了的生命周期标注问题，可以尝试 `T: 'static`，有时候它会给你奇迹

### 3.1.2 深入生命周期[TODO]

### 3.1.3 &'static 和 T: 'static

`'static` 在 Rust 中是相当常见的，例如字符串字面值就具有 `'static` 生命周期:

```rust
fn main() {
    let mark_twain: &str = "Samuel Clemens";
    print_author(mark_twain);
}
fn print_author(author: &'static str) {
    println!("{}", author);
}
```

`'static` 的另一种使用场景:

```rust
use std::fmt::Display;
fn main() {
    let mark_twain = "Samuel Clemens";
    print(&mark_twain);
}

fn print<T: Display + 'static>(message: &T) {
    println!("{}", message);
}
```

#### &'static

`&'static` 对于生命周期有着非常强的要求：一个引用必须要活得跟剩下的程序一样久，才能被标注为 `&'static`。

**`&'static` 生命周期针对的仅仅是引用，而不是持有该引用的变量，对于变量来说，还是要遵循相应的作用域规则。**

####  T: 'static

#### static 到底针对谁？

-   是 `&'static` 这个引用还是该引用指向的数据活得跟程序一样久呢？

    **答案是引用指向的数据**，而引用本身是要遵循其作用域范围的

#### 总结

经验之谈，可以这么来:

-   如果你需要添加 `&'static` 来让代码工作，那很可能是设计上出问题了
-   如果你希望满足和取悦编译器，那就使用 `T: 'static`，很多时候它都能解决问题

## 3.2 函数式编程：闭包、迭代器

### 3.2.1 闭包 `Closure`

闭包：匿名函数，可以赋值给变量或作为参数传递给其他函数，允许捕获调用者作用域中的值。

```rust
fn main() {
   let x = 1;
   let sum = |y| x + y;

    assert_eq!(3, sum(2));
}
```

#### 使用闭包简化代码

通过将函数赋值给某一变量，可以快速调整对此函数的使用。

#### 闭包实现

闭包的形式定义：

```rust
|param1, param2,...| {
    语句1;
    语句2;
    返回表达式
}
or
|param1| 返回表达式
```

#### 闭包类型推导

多数情况下，不需要显式声明类型。

同一功能的函数与闭包实现形式：

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

闭包的类型推导中，**当编译器推导出一种类型后，它就会一直使用该类型**。

```rust
#![allow(unused)]
fn main() {
    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
}
output:
error[E0308]: mismatched types
  --> src/main.rs:13:29
   |
13 |     let n = example_closure(5);
   |                             ^- help: try using a conversion method: `.to_string()`
   |                             |
   |                             expected struct `String`, found integer

For more information about this error, try `rustc --explain E0308`.
```

#### 结构体中的闭包

假设我们要实现一个简易缓存，功能是获取一个值，然后将其缓存起来，那么可以这样设计：

-   一个闭包用于获取值
-   一个变量，用于存储该值

可以使用结构体来代表缓存对象，最终设计如下：

```rust
struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    query: T,
    value: Option<u32>,
}
```

>     Fn 特征不仅仅适用于闭包，还适用于函数

```rust
impl<T> Cacher<T>
where
    T: Fn(u32) -> u32,
{
    fn new(query: T) -> Cacher<T> {
        Cacher {
            query,
            value: None,
        }
    }

    // 先查询缓存值 `self.value`，若不存在，则调用 `query` 加载
    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.query)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
}
```

#### 捕获作用域中的值

```rust
fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```

`x` 并不是闭包 `equal_to_x` 的参数，但是它依然可以去使用 `x`，因为 `equal_to_x` 在 `x` 的作用域范围内。

##### 闭包对内存的影响

当闭包从环境中捕获一个值时，会**分配内存**去存储这些值。

#### 三种 `Fn` 特征

1.   `FnOnce`，该类型的闭包会拿走被捕获变量的所有权。`Once` 顾名思义，说明该闭包只能运行一次：

     ```rust
     fn fn_once<F>(func: F)
     where
         F: FnOnce(usize) -> bool,
     {
         println!("{}", func(3));
         println!("{}", func(4));
     }
     
     fn main() {
         let x = vec![1, 2, 3];
         fn_once(|z| z == x.len())
     }
     ```

     >   **仅**实现 `FnOnce` 特征的闭包在调用时会转移所有权。

2.   `FnMut`，它以可变借用的方式捕获了环境中的值:

     ```rust
     fn main() {
         let mut s = String::new();
     
         let update_string = |str| s.push_str(str);
         update_string("hello");
     
         println!("{:?}", s);
     }
     ```

3.   `Fn` 特征，它以不可变借用的方式捕获环境中的值:

     ```rust
     fn main() {
         let mut s = String::new();
     
         let update_string =  |str| s.push_str(str);
     
         exec(update_string);
     
         println!("{:?}",s);
     }
     
     fn exec<'a, F: Fn(&'a str)>(mut f: F)  {
         f("hello")
     }
     ```

##### `move` 和 `Fn`

**一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量**

##### 三种 `Fn` 的关系

一个闭包并不仅仅实现某一种 `Fn` 特征，规则如下：

-   所有的闭包都自动实现了 `FnOnce` 特征，因此任何一个闭包都至少可以被调用一次
-   没有移出所捕获变量的所有权的闭包自动实现了 `FnMut` 特征
-   不需要对捕获变量进行改变的闭包自动实现了 `Fn` 特征

```rust
fn main() {
    let s = String::new();

    let update_string = || println!("{}", s);

    exec(update_string);
    exec1(update_string);
    exec2(update_string);
}

fn exec<F: FnOnce()>(f: F) {
    f()
}

fn exec1<F: FnMut()>(mut f: F) {
    f()
}

fn exec2<F: Fn()>(f: F) {
    f()
}
```

#### 闭包作为函数返回值

```rust
fn factory(x:i32) -> Box<dyn Fn(i32) -> i32> {
    let num = 5;

    if x > 1{
        Box::new(move |x| x + num)
    } else {
        Box::new(move |x| x - num)
    }
}
```

### 3.2.2 迭代器 `Iterator`

#### `For` 与迭代器

区别在于是否通过**索引**来访问集合

`Rust`中数组实现了 `IntoIterator`特征，通过`for`语法糖将该特征的数组转换为迭代器。

```rust
#![allow(unused)]
fn main() {
    let arr = [1, 2, 3];
    for v in arr {
        println!("{}", v);
    }
}
```

 `IntoIterator` 特征有一个 `into_iter` 方法，可以显式的把数组转换成迭代器：

```rust
#![allow(unused)]
fn main() {
    let arr = [1, 2, 3];
    for v in arr.into_iter() {
        println!("{}", v);
    }
}
```

#### 惰性初始化

Rust中迭代器是惰性的。

#### `IntoIterator`特征

##### `into_iter`, `iter`, `iter_mut`

-   `into_iter` 会夺走所有权
-   `iter` 是借用
-   `iter_mut` 是可变借用

##### `Iterator` 和 `IntoIterator` 的区别

-   `Iterator` 就是迭代器特征，只有实现了它才能称为迭代器，才能调用 `next`
-   `IntoIterator` 强调的是某一个类型如果实现了该特征，它可以通过 `into_iter`，`iter` 等方法变成一个迭代器

#### 消费者与适配器

##### 消费者适配器

迭代器上的某个方法 `A` 在其内部调用了 `next` 方法，那么 `A` 就被称为**消费性适配器**

```rust
fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);

    // v1_iter 是借用了 v1，因此 v1 可以照常使用
    println!("{:?}", v1);

    // 以下代码会报错，因为 `sum` 拿到了迭代器 `v1_iter` 的所有权
    // println!("{:?}",v1_iter);
}
```

##### 迭代器适配器

迭代器适配器，顾名思义，会返回一个新的迭代器。

迭代器适配器是惰性的，意味着你**需要一个消费者适配器来收尾，最终将迭代器转换成一个具体的值**：

```rust
#![allow(unused)]
fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
}
```

## 3.3 深入类型

### 3.3.1 `newtype` 和类型别名

#### `newtype`

使用**元组结构体**的方式将已有的类型包裹起来：`Meters（u32）`，`Meters` 就是一个`newtype`。

好处：

-   自定义类型可以让我们给出更有意义和可读性的类型名
-   对于某些场景，只有 `newtype` 可以很好地解决
-   隐藏内部类型的细节

#### 为外部类型实现外部特征

在外部类型上实现外部特征必须使用 `newtype` 的方式，否则你就得遵循孤儿规则：要为类型 `A` 实现特征 `T`，那么 `A` 或者 `T` 必须至少有一个在当前的作用范围内。

使用 `newtype` 对标注库类型 `Vec` 实现 `Display` 特征：

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}
output:
w = [hello, world]
```

#### 隐藏内部细节

使用 `newtype` 对外隐藏内部细节：

```rust
struct Meters(u32);

fn main() {
    let i: u32 = 2;
    assert_eq!(i.pow(2), 4);

    let n = Meters(i);
    // 下面的代码将报错，因为`Meters`类型上没有`pow`方法
    // assert_eq!(n.pow(2), 4);
}
```

### 类型别名

更传统的方式来创建新类型：类型别名

```rust
type Meters = u32
```

**类型别名并不是一个独立的全新的类型，而是某一个类型的别名**。

### 3.3.2 `Sized` 和不定长类型`DST`

-   定长类型( sized )，这些类型的大小在编译时是已知的
-   不定长类型( unsized )，与定长类型相反，它的大小只有到了程序运行时才能动态获知，这种类型又被称之为 DST

#### 动态大小类型 `DST`

**因为编译器无法在编译期获知类型大小，若你试图在代码中直接使用 DST 类型，将无法通过编译**。

试图创建动态大小数组:

```rust
#![allow(unused)]
fn main() {
    fn my_function(n: usize) {
        let array = [123; n];
    }
}
```

切片:

`str`:

```rust
#![allow(unused)]
fn main() {
    // error
    let s1: str = "Hello there!";
    let s2: str = "How's it going?";

    // ok
    let s3: &str = "on?";
}
```

因此，将动态数据固定化的秘诀就是使用引用指向这些动态数据，然后在引用中存储相关的内存位置、长度等信息。

特征对象:

```rust
#![allow(unused)]
fn main() {
    fn foobar_1(thing: &dyn MyThing) {} // OK
    fn foobar_2(thing: Box<dyn MyThing>) {} // OK
    fn foobar_3(thing: MyThing) {} // ERROR!
}
```

总结：只能间接使用的 DST

Rust 中常见的 `DST` 类型有: `str`、`[T]`、`dyn Trait`，**它们都无法单独被使用，必须要通过引用或者 `Box` 来间接使用** 。

#### `Size` 特征

Rust如何保证泛型参数是固定大小类型的？

编译器自动帮我们加上了 `Sized` 特征：**所有在编译时就能知道其大小的类型，都会自动实现 `Sized` 特征**。

**每一个特征都是一个可以通过名称来引用的动态大小类型**。因此如果想把特征作为具体的类型来传递给函数，你必须将其转换成一个特征对象：诸如 `&dyn Trait` 或者 `Box<dyn Trait>` (还有 `Rc<dyn Trait>`)这些引用类型。

想在泛型函数中使用动态数据类型怎么办？可以使用 `?Sized` 特征：

```rust
#![allow(unused)]
fn main() {
    fn generic<T: ?Sized>(t: &T) {
        // --snip--
    }
}
```

`?Sized` 特征用于表明类型 `T` 是固定大小的类型，或者动态大小的类型。还有一点要注意的是，函数参数类型从 `T` 变成了 `&T`，因为 `T` 可能是动态大小的，因此需要用一个固定大小的指针(引用)来包裹它。

#### `Box<str>`

```rust
#![allow(unused)]
fn main() {
    let s1: Box<str> = "Hello there!".into();
}
```

### 3.4 智能指针

智能指针：通过比引用更复杂的数据结构，包含比引用更多的信息，例如元数据，当前长度，最大可用长度等。

### 3.4.1 `Box` 堆对象分配

 `Box<T>` 允许你将一个值分配到堆上，然后在栈上保留一个智能指针指向堆上的数据。

#### `Rust` 中的堆栈

Rust 堆上对象有一个特殊之处，它们都拥有一个所有者，因此受所有权规则的限制：当赋值时，发生的是所有权的转移（只需浅拷贝栈上的引用或智能指针即可）：

```rust
fn main() {
    let b = foo("world");
    println!("{}", b);
}

fn foo(x: &str) -> String {
    let a = "Hello, ".to_string() + x;
    a
}
```

#### `Box` 使用场景

`Box` 特性：

-   特意将数据分配在堆上
-   数据较大时，又不想在转移所有权时进行数据拷贝
-   类型的大小在编译期无法确定，但是我们又需要固定大小的类型时
-   特征对象，用于说明对象实现了一个特征，而不是某个特定的类型

##### 使用 `Box` 将数据存储在堆上

使用 `Deref` 解引用获取指针所指对象的值。

```rust
fn main() {
    let a = Box::new(3);
    println!("a = {}", a); // a = 3

    // 下面一行代码将报错
    // let b = a + 1; // cannot add `{integer}` to `Box<{integer}>`
}
```

##### 避免栈上数据的拷贝

当栈上数据转移所有权时，实际上是把数据拷贝了一份，最终新旧变量各自拥有不同的数据，因此所有权并未转移。

```rust
fn main() {
    // 在栈上创建一个长度为1000的数组
    let arr = [0; 1000];
    // 将arr所有权转移arr1，由于 `arr` 分配在栈上，因此这里实际上是直接重新深拷贝了一份数据
    let arr1 = arr;

    // arr 和 arr1 都拥有各自的栈上数组，因此不会报错
    println!("{:?}", arr.len());
    println!("{:?}", arr1.len());

    // 在堆上创建一个长度为1000的数组，然后使用一个智能指针指向它
    let arr = Box::new([0; 1000]);
    // 将堆上数组的所有权转移给 arr1，由于数据在堆上，因此仅仅拷贝了智能指针的结构体，底层数据并没有被拷贝
    // 所有权顺利转移给 arr1，arr 不再拥有所有权
    let arr1 = arr;
    println!("{:?}", arr1.len());
    // 由于 arr 不再拥有底层数组的所有权，因此下面代码将报错
    // println!("{:?}", arr.len());
}
```

##### 将动态大小类型变为 `Sized` 固定大小类型

##### 特征对象

实现不同类型组成的数组只有两个办法：枚举和特征对象。

```rust
trait Draw {
    fn draw(&self);
}

struct Button {
    id: u32,
}
impl Draw for Button {
    fn draw(&self) {
        println!("这是屏幕上第{}号按钮", self.id)
    }
}

struct Select {
    id: u32,
}

impl Draw for Select {
    fn draw(&self) {
        println!("这个选择框贼难用{}", self.id)
    }
}

fn main() {
    let elems: Vec<Box<dyn Draw>> = vec![Box::new(Button { id: 1 }), Box::new(Select { id: 2 })];

    for e in elems {
        e.draw()
    }
}
output:
这是屏幕上第1号按钮
这个选择框贼难用2
```

#### `Box::leak`

它可以消费掉 `Box` 并且强制目标值从内存中泄漏。

使用场景：
如果你需要一个在运行期初始化的值，但是可以全局有效，也就是和整个程序活得一样久，那么就可以使用 `Box::leak`。

### 3.4.2 `Deref` 解引用

#### 通过 `*` 获取引用背后的值

对常规引用使用 `*` 操作符，就可以通过解引用的方式获取到内存地址对应的数据值：

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

#### 智能指针解引用

智能指针通过实现 `Deref` 特征，自定义解引用结果：

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

fn main() {
    let y = MyBox::new(5);

    assert_eq!(5, *y);
}
```

需要注意的是：

-   在 `Deref` 特征中声明了关联类型 `Target`，在之前章节中介绍过，关联类型主要是为了提升代码可读性
-   `deref` 返回的是一个常规引用，可以被 `*` 进行解引用

#### `*` 背后原理

智能指针 `Box` 解引用的背后：

```rust
*(y.deref())
```

首先调用 `deref()` 获取常规引用，再通过 `*` 对常规引用解引用，从而获取目标值。

#### 函数和方法中的隐式 `Deref` 转换

若一个类型实现了 `Deref` 特征，那它的引用在传给函数或方法时，会根据参数签名来决定是否进行隐式的 `Deref` 转换：

```rust
fn main() {
    let s = String::from("hello world");
    display(&s)
}

fn display(s: &str) {
    println!("{}", s);
}
```

以上代码有几点值得注意：

-   `String` 实现了 `Deref` 特征，可以在需要时自动被转换为 `&str` 类型
-   `&s` 是一个 `&String` 类型，当它被传给 `display` 函数时，自动通过 `Deref` 转换成了 `&str`
-   必须使用 `&s` 的方式来触发 `Deref`(仅引用类型的实参才会触发自动解引用)

##### 连续的隐式 `Deref` 转换

`Deref` 可以支持连续的隐式转换，直到找到适合的形式为止：

```rust
fn main() {
    let s = MyBox::new(String::from("hello world"));
    display(&s)
}

fn display(s: &str) {
    println!("{}", s);
}
```

#### `Deref` 规则总结

#### 三种 `Deref` 转换

Rust 还支持将一个可变的引用转换成另一个可变的引用以及将一个可变引用转换成不可变的引用，规则如下：

-   当 `T: Deref<Target=U>`，可以将 `&T` 转换成 `&U`，也就是我们之前看到的例子
-   当 `T: DerefMut<Target=U>`，可以将 `&mut T` 转换成 `&mut U`
-   当 `T: Deref<Target=U>`，可以将 `&mut T` 转换成 `&U`

### 3.4.3 `Drop` 释放资源

#### `Rust` 中资源回收

`Rust` 的自动资源回收依靠 `Drop` 特征。

#### `Drop` 的顺序

-   **变量级别，按照逆序的方式**
-   **结构体内部，按照顺序的方式**

#### 手动回收

`Drop::drop` 只是借用了目标值的可变引用，后续代码依旧可以使用目标值。使用 `drop()` 函数获取目标值所有权，手动释放内存。

#### 互斥的 `Copy` 和 `Drop`

无法为一个类型同时实现 `Copy` 和 `Drop` 特征：因为实现了 `Copy` 的特征会被编译器隐式的复制，因此非常难以预测析构函数执行的时间和频率。

### 3.4.4 `Rc` 与 `Arc` 实现 `1vN` 所有权机制

Rust 所有权机制要求一个值只能有一个所有者，在如下情况中：

-   在图数据结构中，多个边可能会拥有同一个节点，该节点直到没有边指向它时，才应该被释放清理
-   在多线程中，多个线程可能会持有同一个数据，但是你受限于 Rust 的安全机制，无法同时获取该数据的可变引用

唯一所有者带来的限制处理起来就会很麻烦。因此 `Rust` 引入额外的实现：引用计数，允许一个数据资源在同一时刻拥有多个所有者。

此种实现机制即为：`Rc` 与 `Arc` ，前者使用单线程，后者适用多线程。

#### `Rc<T>`

使用 `Rc` 解决所有权转移问题：

```rust
use std::rc::Rc;
fn main() {
    let a = Rc::new(String::from("hello, world"));
    let b = Rc::clone(&a);

    assert_eq!(2, Rc::strong_count(&a));
    assert_eq!(Rc::strong_count(&a), Rc::strong_count(&b))
}
```

##### `Rc::clone`

`Rc::clone`仅仅复制智能指针并增加引用计数，因此 `a` 和 `b` 共享底层数据。

##### 引用计数的变化

```rust
use std::rc::Rc;
fn main() {
    let a = Rc::new(String::from("test ref counting"));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Rc::clone(&a);
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Rc::clone(&a);
        println!("count after creating c = {}", Rc::strong_count(&c));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
output:
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```

##### 不可变引用

`Rc<T>` 是指向底层数据的不可变的引用，因此你无法通过它来修改数据，这也符合 Rust 的借用规则：要么存在多个不可变借用，要么只能存在一个可变借用。

##### 小结

-   `Rc/Arc` 是不可变引用，你无法修改它指向的值，只能进行读取，如果要修改，需要配合后面章节的内部可变性 `RefCell` 或互斥锁 `Mutex`
-   一旦最后一个拥有者消失，则资源会自动被回收，这个生命周期是在编译期就确定下来的
-   `Rc` 只能用于同一线程内部，想要用于线程之间的对象共享，你需要使用 `Arc`
-   `Rc<T>` 是一个智能指针，实现了 `Deref` 特征，因此你无需先解开 `Rc` 指针，再使用里面的 `T`，而是可以直接使用 `T`

### 3.4.5 `Cell` 和 `RefCell` 内部可变性

内部可变性的实现是因为 Rust 使用了 `unsafe` 来做到这一点。

#### `Cell`

`Cell` 和 `RefCell` 在功能上没有区别，区别在于 `Cell<T>` 适用于 `T` 实现 `Copy` 的情况：

```rust
use std::cell::Cell;
fn main() {
  let c = Cell::new("asdf");
  let one = c.get();
  c.set("qwer");
  let two = c.get();
  println!("{},{}", one, two);
}
output:
asdf,qwer
```

#### `RefCell`

| Rust 规则                            | 智能指针带来的额外规则                  |
| ------------------------------------ | --------------------------------------- |
| 一个数据只有一个所有者               | `Rc/Arc`让一个数据可以拥有多个所有者    |
| 要么多个不可变借用，要么一个可变借用 | `RefCell`实现编译期可变、不可变引用共存 |
| 违背规则导致**编译错误**             | 违背规则导致**运行时`panic`**           |

##### `RefCell` 为何存在

`RefCell` 正是**用于你确信代码是正确的，而编译器却发生了误判时**。

##### `RefCell` 简单总结

-   与 `Cell` 用于可 `Copy` 的值不同，`RefCell` 用于引用
-   `RefCell` 只是将借用规则从编译期推迟到程序运行期，并不能帮你绕过这个规则
-   `RefCell` 适用于编译期误报或者一个引用被在多处代码使用、修改以至于难于管理借用关系时
-   使用 `RefCell` 时，违背借用规则会导致运行期的 `panic`

## 3.5 循环引用与自引用

### 3.5.1 `Week` 与循环引用

#### `Week`

| `Weak`                                          | `Rc`                                      |
| ----------------------------------------------- | ----------------------------------------- |
| 不计数                                          | 引用计数                                  |
| 不拥有所有权                                    | 拥有值的所有权                            |
| 不阻止值被释放(drop)                            | 所有权计数归零，才能 drop                 |
| 引用的值存在返回 `Some`，不存在返回 `None`      | 引用的值必定存在                          |
| 通过 `upgrade` 取到 `Option<Rc<T>>`，然后再取值 | 通过 `Deref` 自动解引用，取值无需任何操作 |

使用方式简单总结下：**对于父子引用关系，可以让父节点通过 `Rc` 来引用子节点，然后让子节点通过 `Weak` 来引用父节点**。

### 3.5.2 结构体中的自引用

#### 自引用

```rust
struct SelfRef<'a> {
    value: String,

    // 该引用指向上面的value
    pointer_to_value: &'a str,
}
```

#### 使用 `Option`

```rust
struct WhatAboutThis<'a> {
    name: String,
    nickname: Option<&'a str>,
}

fn main() {
    let mut tricky = WhatAboutThis {
        name: "Annabelle".to_string(),
        nickname: None,
    };
    tricky.nickname = Some(&tricky.name[..4]);

    println!("{:?}", tricky);
}
output:
WhatAboutThis { name: "Annabelle", nickname: Some("Anna") }
```

#### `Unsafe` 实现

```rust
#[derive(Debug)]
struct SelfRef {
    value: String,
    pointer_to_value: *const String,
}

impl SelfRef {
    fn new(txt: &str) -> Self {
        SelfRef {
            value: String::from(txt),
            pointer_to_value: std::ptr::null(),
        }
    }

    fn init(&mut self) {
        let self_ref: *const String = &self.value;
        self.pointer_to_value = self_ref;
    }

    fn value(&self) -> &str {
        &self.value
    }

    fn pointer_to_value(&self) -> &String {
        assert!(
            !self.pointer_to_value.is_null(),
            "Test::b called without Test::init being called first"
        );
        unsafe { &*(self.pointer_to_value) }
    }
}

fn main() {
    let mut t = SelfRef::new("hello");
    t.init();
    // 打印值和指针地址
    println!("{}, {:p}", t.value(), t.pointer_to_value());
}
output:
hello, 0x7ff7b951b398
```

#### 无法被移动的 `Pin`

`Pin` 可以固定住一个值，防止该值在内存中被移动。

```rust
use std::marker::PhantomPinned;
use std::pin::Pin;
use std::ptr::NonNull;

// 下面是一个自引用数据结构体，因为 slice 字段是一个指针，指向了 data 字段
// 我们无法使用普通引用来实现，因为违背了 Rust 的编译规则
// 因此，这里我们使用了一个裸指针，通过 NonNull 来确保它不会为 null
struct Unmovable {
    data: String,
    slice: NonNull<String>,
    _pin: PhantomPinned,
}

impl Unmovable {
    // 为了确保函数返回时数据的所有权不会被转移，我们将它放在堆上，唯一的访问方式就是通过指针
    fn new(data: String) -> Pin<Box<Self>> {
        let res = Unmovable {
            data,
            // 只有在数据到位时，才创建指针，否则数据会在开始之前就被转移所有权
            slice: NonNull::dangling(),
            _pin: PhantomPinned,
        };
        let mut boxed = Box::pin(res);

        let slice = NonNull::from(&boxed.data);
        // 这里其实安全的，因为修改一个字段不会转移整个结构体的所有权
        unsafe {
            let mut_ref: Pin<&mut Self> = Pin::as_mut(&mut boxed);
            Pin::get_unchecked_mut(mut_ref).slice = slice;
        }
        boxed
    }
}

fn main() {
    let unmoved = Unmovable::new("hello".to_string());
    // 只要结构体没有被转移，那指针就应该指向正确的位置，而且我们可以随意移动指针
    let mut still_unmoved = unmoved;
    assert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));

    // 因为我们的类型没有实现 `Unpin` 特征，下面这段代码将无法编译
    // let mut new_unmoved = Unmovable::new("world".to_string());
    // std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);
}
```

## 3.6 多线程并发编程

### 3.6.1 并发与并行

并发和并行都是对“多任务”处理的描述，其中并发是轮流处理，而并行是同时处理。

### 3.6.2 使用多线程

#### 多线程编程的风险

-   竞态条件
-   死锁
-   隐晦的BUG

#### 创建线程

```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
output:
hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 3 from the main thread!
hi number 4 from the spawned thread!
hi number 4 from the main thread!
hi number 5 from the spawned thread!
```

:warning: 注意：

-   线程内部的代码使用闭包来执行
-   `main` 线程一旦结束，程序就立刻结束
-   `thread::sleep` 会让当前线程休眠指定的时间，随后其它线程会被调度运行

#### 等待子线程结束

通过调用 `handle.join`，可以让当前线程阻塞，直到它等待的子线程的结束。

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..5 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
output:
hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
```

#### 线程闭包中使用 `Move`

可以使用 `move` 来将所有权从一个线程转移到另外一个线程。

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();

    // 下面代码会报错borrow of moved value: `v`
    // println!("{:?}",v);
}
output:
Here's a vector: [1, 2, 3]
```

#### 线程结束

线程代码执行完成，线程就会自动结束。如果不会执行完：

-   IO型的任务，CPU占用比较小，线程大部分处于阻塞状态
-   CPU密集型任务，如果没有终止条件，可能会跑满CPU核心，直至 `main` 线程结束

```rust
use std::thread;
use std::time::Duration;
fn main() {
    // 创建一个线程A
    let new_thread = thread::spawn(move || {
        // 再创建一个线程B
        thread::spawn(move || {
            loop {
                println!("I am a new thread.");
            }
        })
    });

    // 等待新创建的线程执行完成
    new_thread.join().unwrap();
    println!("Child thread is finish!");

    // 睡眠一段时间，看子线程创建的子线程是否还在运行
    thread::sleep(Duration::from_millis(100));
}
```

#### 线程屏障

使用 `Barrier` 让多个线程都执行到某个点后，才继续一起往后执行：

```rust
use std::sync::{Arc, Barrier};
use std::thread;

fn main() {
    let mut handles = Vec::with_capacity(6);
    let barrier = Arc::new(Barrier::new(6));

    for _ in 0..6 {
        let b = barrier.clone();
        handles.push(thread::spawn(move|| {
            println!("before wait");
            b.wait();
            println!("after wait");
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
output:
before wait
before wait
before wait
before wait
before wait
before wait
after wait
after wait
after wait
after wait
after wait
after wait
```

#### 线程局部变量

```rust
#![allow(unused)]
fn main() {
    use std::cell::RefCell;
    use std::thread;

    thread_local!(static FOO: RefCell<u32> = RefCell::new(1));

    FOO.with(|f| {
        assert_eq!(*f.borrow(), 1);
        *f.borrow_mut() = 2;
    });

    // 每个线程开始时都会拿到线程局部变量的FOO的初始值
    let t = thread::spawn(move || {
        FOO.with(|f| {
            assert_eq!(*f.borrow(), 1);
            *f.borrow_mut() = 3;
        });
    });

    // 等待线程完成
    t.join().unwrap();

    // 尽管子线程中修改为了3，我们在这里依然拥有main线程中的局部值：2
    FOO.with(|f| {
        assert_eq!(*f.borrow(), 2);
    });
}
```

#### 条件控制

```rust
use std::sync::{Arc, Condvar, Mutex};
use std::thread;

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = pair.clone();

    thread::spawn(move || {
        let &(ref lock, ref cvar) = &*pair2;
        let mut started = lock.lock().unwrap();
        println!("changing started");
        *started = true;
        cvar.notify_one();
    });

    let &(ref lock, ref cvar) = &*pair;
    let mut started = lock.lock().unwrap();
    while !*started {
        started = cvar.wait(started).unwrap();
    }

    println!("started changed");
}
```

#### 只被调用一次的函数

```rust
use std::thread;
use std::sync::Once;

static mut VAL: usize = 0;
static INIT: Once = Once::new();

fn main() {
    let handle1 = thread::spawn(move || {
        INIT.call_once(|| {
            unsafe {
                VAL = 1;
            }
        });
    });

    let handle2 = thread::spawn(move || {
        INIT.call_once(|| {
            unsafe {
                VAL = 2;
            }
        });
    });

    handle1.join().unwrap();
    handle2.join().unwrap();

    println!("{}", unsafe { VAL });
}
```

### 3.6.3 线程同步：消息传递

>   Do not communicate by sharing memory; instead, share memory by communicating

#### 消息通道

`Rust` 提供消息通道（`Channel`），支持**多发多收**特性。

#### 多发单收

标准库提供了通道`std::sync::mpsc`。

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    // 创建一个消息通道, 返回一个元组：(发送者，接收者)
    let (tx, rx) = mpsc::channel();

    // 创建线程，并发送消息
    thread::spawn(move || {
        // 发送一个数字1, send方法返回Result<T,E>，通过unwrap进行快速错误处理
        tx.send(1).unwrap();

        // 下面代码将报错，因为编译器自动推导出通道传递的值是i32类型，那么Option<i32>类型将产生不匹配错误
        // tx.send(Some(1)).unwrap()
    });

    // 在主线程中接收子线程发送的消息并输出
    println!("receive {}", rx.recv().unwrap());
}
output:
receive 1
```

#### 不阻塞的 `try_recv` 方法

该方法并**不会阻塞线程**，当通道中没有消息时，它会立刻返回一个错误：

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        tx.send(1).unwrap();
    });

    println!("receive {:?}", rx.try_recv());
}
output:
receive Err(empty)
```

#### 具有所有权的数据

使用通道来传输数据，一样要遵循 Rust 的所有权规则：

-   若值的类型实现了`Copy`特征，则直接复制一份该值，然后传输过去，例如之前的`i32`类型
-   若值没有实现`Copy`，则它的所有权会被转移给接收端，在发送端继续使用该值将报错

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let s = String::from("我，飞走咯!");
        tx.send(s).unwrap();
        println!("val is {}", s); // value moved here
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```

#### 循环接收数据

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
}
```

#### 多发送者

子线程会拿走发送者的所有权，因此我们必须对发送者进行克隆，然后让每个线程拿走它的一份拷贝:

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();
    let tx1 = tx.clone();
    thread::spawn(move || {
        tx.send(String::from("hi from raw tx")).unwrap();
    });

    thread::spawn(move || {
        tx1.send(String::from("hi from cloned tx")).unwrap();
    });

    for received in rx {
        println!("Got: {}", received);
    }
}
```

#### 消息顺序

`FIFO` 原则

#### 同步 & 异步通道

##### 异步通道

无论接收者是否正在接收消息，消息发送者在发送消息时都不会阻塞:

```rust
// async channel
use std::sync::mpsc;
use std::thread;
use std::time::Duration;
fn main() {
    let (tx, rx) = mpsc::channel();

    let handle = thread::spawn(move || {
        println!("发送之前");
        tx.send(1).unwrap();
        println!("发送之后");
    });

    println!("睡眠之前");
    thread::sleep(Duration::from_secs(3));
    println!("睡眠之后");

    println!("receive {}", rx.recv().unwrap());
    handle.join().unwrap();
}
output:
睡眠之前
发送之前
发送之后
睡眠之后
receive 1
```

##### 同步通道

同步通道**发送消息是阻塞的，只有在消息被接收后才解除阻塞**:

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;
fn main() {
    let (tx, rx) = mpsc::sync_channel(0);

    let handle = thread::spawn(move || {
        println!("发送之前");
        tx.send(1).unwrap();
        println!("发送之后");
    });

    println!("睡眠之前");
    thread::sleep(Duration::from_secs(3));
    println!("睡眠之后");

    println!("receive {}", rx.recv().unwrap());
    handle.join().unwrap();
}
output:
睡眠之前
发送之前
睡眠之后
receive 1
发送之后
```

##### 消息缓存

通过创建通道时传递参数`mpsc::sync_channel(N);` N，来设置缓存大小。

#### 关闭通道

**所有发送者被`drop`或者所有接收者被`drop`后，通道会自动关闭**。

#### 传输多种类型

```rust
use std::sync::mpsc::{self, Receiver, Sender};

enum Fruit {
    Apple(u8),
    Orange(String)
}

fn main() {
    let (tx, rx): (Sender<Fruit>, Receiver<Fruit>) = mpsc::channel();

    tx.send(Fruit::Orange("sweet".to_string())).unwrap();
    tx.send(Fruit::Apple(2)).unwrap();

    for _ in 0..2 {
        match rx.recv().unwrap() {
            Fruit::Apple(count) => println!("received {} apples", count),
            Fruit::Orange(flavor) => println!("received {} oranges", flavor),
        }
    }
}
output:
received sweet oranges
received 2 apples
```

### 3.6.4 线程同步：锁、Condvar、信号量

#### 互斥锁 `Mutex`

##### 单线程中使用 `Mutex`

```rust
use std::sync::Mutex;

fn main() {
    // 使用`Mutex`结构体的关联函数创建新的互斥锁实例
    let m = Mutex::new(5);

    {
        // 获取锁，然后deref为`m`的引用
        // lock返回的是Result
        let mut num = m.lock().unwrap();
        *num = 6;
        // 锁自动被drop
    }

    println!("m = {:?}", m);
}
output:
m = Mutex { data: 6, poisoned: false, .. }
```

##### 多线程中使用 `Mutex`

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
output:
Result: 10
```

##### 内部可变性

简单总结下：`Rc<T>/RefCell<T>`用于单线程内部可变性， `Arc<T>/Mutext<T>`用于多线程内部可变性。

#### 死锁

##### 单线程死锁

```rust
use std::sync::Mutex;

fn main() {
    let data = Mutex::new(0);
    let d1 = data.lock();
    let d2 = data.lock();
} // d1锁在此处释放
```

##### 多线程死锁

```rust
use std::thread::sleep;
use std::time::Duration;
use std::{
    sync::{Mutex, MutexGuard},
    thread,
};

use lazy_static::lazy_static;
lazy_static! {
    static ref MUTEX1: Mutex<i64> = Mutex::new(0);
    static ref MUTEX2: Mutex<i64> = Mutex::new(0);
}

fn main() {
    // 存放子线程的句柄
    let mut children = vec![];
    for i_thread in 0..2 {
        children.push(thread::spawn(move || {
            for _ in 0..1 {
                // 线程1
                if i_thread % 2 == 0 {
                    // 锁住MUTEX1
                    let guard: MutexGuard<i64> = MUTEX1.lock().unwrap();

                    println!("线程 {} 锁住了MUTEX1，接着准备去锁MUTEX2 !", i_thread);

                    // 当前线程睡眠一小会儿，等待线程2锁住MUTEX2
                    sleep(Duration::from_millis(10));

                    // 去锁MUTEX2
                    let guard = MUTEX2.lock().unwrap();
                // 线程2
                } else {
                    // 锁住MUTEX2
                    let _guard = MUTEX2.lock().unwrap();

                    println!("线程 {} 锁住了MUTEX2, 准备去锁MUTEX1", i_thread);

                    let _guard = MUTEX1.lock().unwrap();
                }
            }
        }));
    }

    // 等子线程完成
    for child in children {
        let _ = child.join();
    }

    println!("死锁没有发生");
}
```

##### `try_lock`

 `try_lock`会**尝试**去获取一次锁，如果无法获取会返回一个错误，因此**不会发生阻塞**。

#### 读写锁 `RwLock`

```rust
use std::sync::RwLock;

fn main() {
    let lock = RwLock::new(5);

    // 同一时间允许多个读
    {
        let r1 = lock.read().unwrap();
        let r2 = lock.read().unwrap();
        assert_eq!(*r1, 5);
        assert_eq!(*r2, 5);
    } // 读锁在此处被drop

    // 同一时间只允许一个写
    {
        let mut w = lock.write().unwrap();
        *w += 1;
        assert_eq!(*w, 6);

        // 以下代码会panic，因为读和写不允许同时存在
        // 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中
        // let r1 = lock.read();
        // println!("{:?}",r1);
    }// 写锁在此处被drop
}
```

简单总结下`RwLock`:

1.  同时允许多个读，但最多只能有一个写
2.  读和写不能同时存在
3.  读可以使用`read`、`try_read`，写`write`、`try_write`, 在实际项目中，`try_xxx`会安全的多

#### 条件变量（Condvar）控制线程同步

```rust
use std::sync::{Arc,Mutex,Condvar};
use std::thread::{spawn,sleep};
use std::time::Duration;

fn main() {
    let flag = Arc::new(Mutex::new(false));
    let cond = Arc::new(Condvar::new());
    let cflag = flag.clone();
    let ccond = cond.clone();

    let hdl = spawn(move || {
        let mut m = { *cflag.lock().unwrap() };
        let mut counter = 0;

        while counter < 3 {
            while !m {
                m = *ccond.wait(cflag.lock().unwrap()).unwrap();
            }

            {
                m = false;
                *cflag.lock().unwrap() = false;
            }

            counter += 1;
            println!("inner counter: {}", counter);
        }
    });

    let mut counter = 0;
    loop {
        sleep(Duration::from_millis(1000));
        *flag.lock().unwrap() = true;
        counter += 1;
        if counter > 3 {
            break;
        }
        println!("outside counter: {}", counter);
        cond.notify_one();
    }
    hdl.join().unwrap();
    println!("{:?}", flag);
}
output:
outside counter: 1
inner counter: 1
outside counter: 2
inner counter: 2
outside counter: 3
inner counter: 3
Mutex { data: true, poisoned: false, .. }
```

#### 信号量 `Semaphore`

```rust
use std::sync::Arc;
use tokio::sync::Semaphore;

#[tokio::main]
async fn main() {
    let semaphore = Arc::new(Semaphore::new(3));
    let mut join_handles = Vec::new();

    for _ in 0..5 {
        let permit = semaphore.clone().acquire_owned().await.unwrap();
        join_handles.push(tokio::spawn(async move {
            //
            // 在这里执行任务...
            //
            drop(permit);
        }));
    }

    for handle in join_handles {
        handle.await.unwrap();
    }
}
```

### 3.6.5 线程同步：`Atomic` 原子操作与内存顺序

#### 使用 `Atomic` 作为全局变量

```rust
use std::ops::Sub;
use std::sync::atomic::{AtomicU64, Ordering};
use std::thread::{self, JoinHandle};
use std::time::Instant;

const N_TIMES: u64 = 10000000;
const N_THREADS: usize = 10;

static R: AtomicU64 = AtomicU64::new(0);

fn add_n_times(n: u64) -> JoinHandle<()> {
    thread::spawn(move || {
        for _ in 0..n {
            R.fetch_add(1, Ordering::Relaxed);
        }
    })
}

fn main() {
    let s = Instant::now();
    let mut threads = Vec::with_capacity(N_THREADS);

    for _ in 0..N_THREADS {
        threads.push(add_n_times(N_TIMES));
    }

    for thread in threads {
        thread.join().unwrap();
    }

    assert_eq!(N_TIMES * N_THREADS as u64, R.load(Ordering::Relaxed));

    println!("{:?}",Instant::now().sub(s));
}
```

#### 内存顺序

内存顺序是指 CPU 在访问内存时的顺序，该顺序可能受以下因素的影响：

-   代码中的先后顺序
-   编译器优化导致在编译阶段发生改变(内存重排序 reordering)
-   运行阶段因 CPU 的缓存机制导致顺序被打乱

##### 限定内存顺序的5个规则

`Ordering` 枚举有 5 个成员:

-   **Relaxed**， 这是最宽松的规则，它对编译器和 CPU 不做任何限制，可以乱序
-   **Release 释放**，设定内存屏障(Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面
-   **Acquire 获取**, 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和`Release`在不同线程中联合使用
-   **AcqRel**, 是 *Acquire* 和 *Release* 的结合，同时拥有它们俩提供的保证。比如你要对一个 `atomic` 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序
-   **SeqCst 顺序一致性**， `SeqCst`就像是`AcqRel`的加强版，它不管原子操作是属于读取还是写入的操作，只要某个线程有用到`SeqCst`的原子操作，线程中该`SeqCst`操作前的数据操作绝对不会被重新排在该`SeqCst`操作之后，且该`SeqCst`操作后的数据操作也绝对不会被重新排在`SeqCst`操作前。

##### 内存屏障

```rust
use std::sync::atomic::{AtomicBool, Ordering};
use std::thread::{self, JoinHandle};

static mut DATA: u64 = 0;
static READY: AtomicBool = AtomicBool::new(false);

fn reset() {
    unsafe {
        DATA = 0;
    }
    READY.store(false, Ordering::Relaxed);
}

fn producer() -> JoinHandle<()> {
    thread::spawn(move || {
        unsafe {
            DATA = 100; // A
        }
        READY.store(true, Ordering::Release); // B: 内存屏障 ↑
    })
}

fn consumer() -> JoinHandle<()> {
    thread::spawn(move || {
        while !READY.load(Ordering::Acquire) {} // C: 内存屏障 ↓

        assert_eq!(100, unsafe { DATA }); // D
    })
}

fn main() {
    loop {
        reset();

        let t_producer = producer();
        let t_consumer = consumer();

        t_producer.join().unwrap();
        t_consumer.join().unwrap();
    }
}
```

#### 多线程使用 `Atomic`

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::{hint, thread};

fn main() {
    let spinlock = Arc::new(AtomicUsize::new(1));

    let spinlock_clone = Arc::clone(&spinlock);
    let thread = thread::spawn(move || {
        spinlock_clone.store(0, Ordering::SeqCst);
    });

    // 等待其它线程释放锁
    while spinlock.load(Ordering::SeqCst) != 0 {
        hint::spin_loop();
    }

    if let Err(panic) = thread.join() {
        println!("Thread had an error: {:?}", panic);
    }
}
```

