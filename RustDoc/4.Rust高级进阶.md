## 3.1 生命周期

### 3.1.1 认识生命周期

生命周期，简而言之就是引用的有效作用域。

多数情况下编译器可以自动进行推导，用类型来类比下：

-   就像编译器大部分时候可以自动推导类型 <-> 一样，编译器大多数时候也可以自动推导生命周期
-   在多种类型存在时，编译器往往要求我们手动标明类型 <-> 当多个生命周期存在，且编译器无法推导出某个引用的生命周期时，就需要我们手动标明生命周期

#### 悬垂指针与生命周期

生命周期的主要作用是避免悬垂引用，它会导致程序引用了本不该引用的数据：

```rust
#![allow(unused)]
fn main() {
    {
        let r;

        {
            let x = 5;
            r = &x;
        }

        println!("r: {}", r);
    }
}
```

代码有几点值得注意:

-   `let r;` 的声明方式貌似存在使用 `null` 的风险，实际上，当我们不初始化它就使用时，编译器会给予报错
-   `r` 引用了内部花括号中的 `x` 变量，但是 `x` 会在内部花括号 `}` 处被释放，因此回到外部花括号后，`r` 会引用一个无效的 `x`

 `r` 就是一个悬垂指针，它引用了提前被释放的变量 `x`

#### 借用检查

为保证 Rust 的所有权和借用的正确性，Rust 使用了一个借用检查器(Borrow checker)来检查我们程序借用的正确性：

```txt
#![allow(unused)]
fn main() {
    {
        let r;                        // ---------+-- 'a
                                      //          |
        {                             //          |
                                      //          |
            let x = 5;                // -+-- 'b  |
            r = &x;                   //  |       |
        }                             // -+       |
                                      //          |
        println!("r: {}", r);         //          |
    }                                 // ---------+
}
```

编译器，Rust 会检查两个变量的生命周期，因为 `r` 的生命周期 `'a`  比 `x` 的生命周期 `'b` 要大，因此拒绝运行。

#### 函数中的生命周期

思考下面的例子：

```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
output:
error[E0106]: missing lifetime specifier
  --> src/main.rs:22:33
   |
22 | fn longest(x: &str, y: &str) -> &str {
   |               ----     ----     ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
   |
22 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
   |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
```

编译器无法知道该函数的返回值到底引用 `x` 还是 `y` ，**因为编译器需要知道这些，来确保函数调用后的引用生命周期分析**。

在存在多个引用时，编译器有时会无法自动推导生命周期，此时就需要我们手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查的分析。

#### 生命周期标注语法

>   生命周期标注并不会改变任何引用的实际作用域

语法：以 `'` 开头，名称往往是一个单独的小写字母。eg: 'a.

引用类型参数 -> 生命周期会位于引用符号 `&` 之后，并用一个空格隔开。 eg: `&'a i32`

```rust
&i32        // 一个引用
&'a i32     // 具有显式生命周期的引用
&'a mut i32 // 具有显式生命周期的可变引用
```

##### 函数签名中的生命周期标注

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

需要注意的点如下：

-   和泛型一样，使用生命周期参数，需要先声明 `<'a>`
-   `x`、`y` 和返回值至少活得和 `'a` 一样久(因为返回值要么是 `x`，要么是 `y`)

##### 深入思考生命周期标注

**函数的返回值如果是一个引用类型，那么它的生命周期只会来源于**：

-   函数参数的生命周期
-   函数体中某个新建引用的生命周期

若是后者情况，就是典型的悬垂引用场景：最好的办法就是返回内部字符串的所有权，然后把字符串的所有权转移给调用者。

对生命周期进行下总结：生命周期语法用来将函数的多个引用参数和返回值的作用域关联到一起，一旦关联到一起后，Rust 就拥有充分的信息来确保我们的操作是内存安全的。

#### 结构体中的生命周期

为结构体中每一项引用标注生命周期即可：

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

**结构体 `ImportantExcerpt` 所引用的字符串 `str` 必须比该结构体活得更久**

#### 生命周期消除

注意：

-   消除规则不是万能的，若编译器不能确定某件事是正确时，会直接判为不正确，那么你还是需要手动标注生命周期
-   **函数或者方法中，参数的生命周期被称为 `输入生命周期`，返回值的生命周期被称为 `输出生命周期`**

##### 三条消除规则

1.   **每一个引用参数都会获得独自的生命周期**
2.   **若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期**
3.   **若存在多个输入生命周期，且其中一个是 `&self` 或 `&mut self`，则 `&self` 的生命周期被赋给所有的输出生命周期**

#### 方法中的生命周期

为具有生命周期的结构体实现方法时，我们使用的语法跟泛型参数语法很相似：

```rust
#![allow(unused)]
fn main() {
    struct ImportantExcerpt<'a> {
        part: &'a str,
    }

    impl<'a> ImportantExcerpt<'a> {
        fn level(&self) -> i32 {
            3
        }
    }
}
```

#### 静态生命周期

Rust 中有一个非常特殊的生命周期，那就是 `'static`，拥有该生命周期的引用可以和整个程序活得一样久。

总结如下：

-   生命周期 `'static` 意味着能和程序活得一样久，例如字符串字面量和特征对象
-   实在遇到解决不了的生命周期标注问题，可以尝试 `T: 'static`，有时候它会给你奇迹

### 3.1.2 深入生命周期[TODO]

### 3.1.3 &'static 和 T: 'static

`'static` 在 Rust 中是相当常见的，例如字符串字面值就具有 `'static` 生命周期:

```rust
fn main() {
    let mark_twain: &str = "Samuel Clemens";
    print_author(mark_twain);
}
fn print_author(author: &'static str) {
    println!("{}", author);
}
```

`'static` 的另一种使用场景:

```rust
use std::fmt::Display;
fn main() {
    let mark_twain = "Samuel Clemens";
    print(&mark_twain);
}

fn print<T: Display + 'static>(message: &T) {
    println!("{}", message);
}
```

#### &'static

`&'static` 对于生命周期有着非常强的要求：一个引用必须要活得跟剩下的程序一样久，才能被标注为 `&'static`。

**`&'static` 生命周期针对的仅仅是引用，而不是持有该引用的变量，对于变量来说，还是要遵循相应的作用域规则。**

####  T: 'static

#### static 到底针对谁？

-   是 `&'static` 这个引用还是该引用指向的数据活得跟程序一样久呢？

    **答案是引用指向的数据**，而引用本身是要遵循其作用域范围的

#### 总结

经验之谈，可以这么来:

-   如果你需要添加 `&'static` 来让代码工作，那很可能是设计上出问题了
-   如果你希望满足和取悦编译器，那就使用 `T: 'static`，很多时候它都能解决问题

## 3.2 函数式编程：闭包、迭代器

### 3.2.1 闭包 `Closure`

闭包：匿名函数，可以赋值给变量或作为参数传递给其他函数，允许捕获调用者作用域中的值。

```rust
fn main() {
   let x = 1;
   let sum = |y| x + y;

    assert_eq!(3, sum(2));
}
```

#### 使用闭包简化代码

通过将函数赋值给某一变量，可以快速调整对此函数的使用。

#### 闭包实现

闭包的形式定义：

```rust
|param1, param2,...| {
    语句1;
    语句2;
    返回表达式
}
or
|param1| 返回表达式
```

#### 闭包类型推导

多数情况下，不需要显式声明类型。

同一功能的函数与闭包实现形式：

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

闭包的类型推导中，**当编译器推导出一种类型后，它就会一直使用该类型**。

```rust
#![allow(unused)]
fn main() {
    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
}
output:
error[E0308]: mismatched types
  --> src/main.rs:13:29
   |
13 |     let n = example_closure(5);
   |                             ^- help: try using a conversion method: `.to_string()`
   |                             |
   |                             expected struct `String`, found integer

For more information about this error, try `rustc --explain E0308`.
```

#### 结构体中的闭包

假设我们要实现一个简易缓存，功能是获取一个值，然后将其缓存起来，那么可以这样设计：

-   一个闭包用于获取值
-   一个变量，用于存储该值

可以使用结构体来代表缓存对象，最终设计如下：

```rust
struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    query: T,
    value: Option<u32>,
}
```

>     Fn 特征不仅仅适用于闭包，还适用于函数

```rust
impl<T> Cacher<T>
where
    T: Fn(u32) -> u32,
{
    fn new(query: T) -> Cacher<T> {
        Cacher {
            query,
            value: None,
        }
    }

    // 先查询缓存值 `self.value`，若不存在，则调用 `query` 加载
    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.query)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
}
```

#### 捕获作用域中的值

```rust
fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```

`x` 并不是闭包 `equal_to_x` 的参数，但是它依然可以去使用 `x`，因为 `equal_to_x` 在 `x` 的作用域范围内。

##### 闭包对内存的影响

当闭包从环境中捕获一个值时，会**分配内存**去存储这些值。

#### 三种 `Fn` 特征

1.   `FnOnce`，该类型的闭包会拿走被捕获变量的所有权。`Once` 顾名思义，说明该闭包只能运行一次：

     ```rust
     fn fn_once<F>(func: F)
     where
         F: FnOnce(usize) -> bool,
     {
         println!("{}", func(3));
         println!("{}", func(4));
     }
     
     fn main() {
         let x = vec![1, 2, 3];
         fn_once(|z| z == x.len())
     }
     ```

     >   **仅**实现 `FnOnce` 特征的闭包在调用时会转移所有权。

2.   `FnMut`，它以可变借用的方式捕获了环境中的值:

     ```rust
     fn main() {
         let mut s = String::new();
     
         let update_string = |str| s.push_str(str);
         update_string("hello");
     
         println!("{:?}", s);
     }
     ```

3.   `Fn` 特征，它以不可变借用的方式捕获环境中的值:

     ```rust
     fn main() {
         let mut s = String::new();
     
         let update_string =  |str| s.push_str(str);
     
         exec(update_string);
     
         println!("{:?}",s);
     }
     
     fn exec<'a, F: Fn(&'a str)>(mut f: F)  {
         f("hello")
     }
     ```

##### `move` 和 `Fn`

**一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量**

##### 三种 `Fn` 的关系

一个闭包并不仅仅实现某一种 `Fn` 特征，规则如下：

-   所有的闭包都自动实现了 `FnOnce` 特征，因此任何一个闭包都至少可以被调用一次
-   没有移出所捕获变量的所有权的闭包自动实现了 `FnMut` 特征
-   不需要对捕获变量进行改变的闭包自动实现了 `Fn` 特征

```rust
fn main() {
    let s = String::new();

    let update_string = || println!("{}", s);

    exec(update_string);
    exec1(update_string);
    exec2(update_string);
}

fn exec<F: FnOnce()>(f: F) {
    f()
}

fn exec1<F: FnMut()>(mut f: F) {
    f()
}

fn exec2<F: Fn()>(f: F) {
    f()
}
```

#### 闭包作为函数返回值

```rust
fn factory(x:i32) -> Box<dyn Fn(i32) -> i32> {
    let num = 5;

    if x > 1{
        Box::new(move |x| x + num)
    } else {
        Box::new(move |x| x - num)
    }
}
```



