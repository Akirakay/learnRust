## 3.1 生命周期

### 3.1.1 认识生命周期

生命周期，简而言之就是引用的有效作用域。

多数情况下编译器可以自动进行推导，用类型来类比下：

-   就像编译器大部分时候可以自动推导类型 <-> 一样，编译器大多数时候也可以自动推导生命周期
-   在多种类型存在时，编译器往往要求我们手动标明类型 <-> 当多个生命周期存在，且编译器无法推导出某个引用的生命周期时，就需要我们手动标明生命周期

#### 悬垂指针与生命周期

生命周期的主要作用是避免悬垂引用，它会导致程序引用了本不该引用的数据：

```rust
#![allow(unused)]
fn main() {
    {
        let r;

        {
            let x = 5;
            r = &x;
        }

        println!("r: {}", r);
    }
}
```

代码有几点值得注意:

-   `let r;` 的声明方式貌似存在使用 `null` 的风险，实际上，当我们不初始化它就使用时，编译器会给予报错
-   `r` 引用了内部花括号中的 `x` 变量，但是 `x` 会在内部花括号 `}` 处被释放，因此回到外部花括号后，`r` 会引用一个无效的 `x`

 `r` 就是一个悬垂指针，它引用了提前被释放的变量 `x`

#### 借用检查

为保证 Rust 的所有权和借用的正确性，Rust 使用了一个借用检查器(Borrow checker)来检查我们程序借用的正确性：

```txt
#![allow(unused)]
fn main() {
    {
        let r;                        // ---------+-- 'a
                                      //          |
        {                             //          |
                                      //          |
            let x = 5;                // -+-- 'b  |
            r = &x;                   //  |       |
        }                             // -+       |
                                      //          |
        println!("r: {}", r);         //          |
    }                                 // ---------+
}
```

编译器，Rust 会检查两个变量的生命周期，因为 `r` 的生命周期 `'a`  比 `x` 的生命周期 `'b` 要大，因此拒绝运行。

#### 函数中的生命周期

思考下面的例子：

```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
output:
error[E0106]: missing lifetime specifier
  --> src/main.rs:22:33
   |
22 | fn longest(x: &str, y: &str) -> &str {
   |               ----     ----     ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
   |
22 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
   |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
```

编译器无法知道该函数的返回值到底引用 `x` 还是 `y` ，**因为编译器需要知道这些，来确保函数调用后的引用生命周期分析**。

在存在多个引用时，编译器有时会无法自动推导生命周期，此时就需要我们手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查的分析。

#### 生命周期标注语法

>   生命周期标注并不会改变任何引用的实际作用域

语法：以 `'` 开头，名称往往是一个单独的小写字母。eg: 'a.

引用类型参数 -> 生命周期会位于引用符号 `&` 之后，并用一个空格隔开。 eg: `&'a i32`

```rust
&i32        // 一个引用
&'a i32     // 具有显式生命周期的引用
&'a mut i32 // 具有显式生命周期的可变引用
```

##### 函数签名中的生命周期标注

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

需要注意的点如下：

-   和泛型一样，使用生命周期参数，需要先声明 `<'a>`
-   `x`、`y` 和返回值至少活得和 `'a` 一样久(因为返回值要么是 `x`，要么是 `y`)

##### 深入思考生命周期标注

**函数的返回值如果是一个引用类型，那么它的生命周期只会来源于**：

-   函数参数的生命周期
-   函数体中某个新建引用的生命周期

若是后者情况，就是典型的悬垂引用场景：最好的办法就是返回内部字符串的所有权，然后把字符串的所有权转移给调用者。

对生命周期进行下总结：生命周期语法用来将函数的多个引用参数和返回值的作用域关联到一起，一旦关联到一起后，Rust 就拥有充分的信息来确保我们的操作是内存安全的。

#### 结构体中的生命周期

为结构体中每一项引用标注生命周期即可：

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

**结构体 `ImportantExcerpt` 所引用的字符串 `str` 必须比该结构体活得更久**

#### 生命周期消除

注意：

-   消除规则不是万能的，若编译器不能确定某件事是正确时，会直接判为不正确，那么你还是需要手动标注生命周期
-   **函数或者方法中，参数的生命周期被称为 `输入生命周期`，返回值的生命周期被称为 `输出生命周期`**

##### 三条消除规则

1.   **每一个引用参数都会获得独自的生命周期**
2.   **若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期**
3.   **若存在多个输入生命周期，且其中一个是 `&self` 或 `&mut self`，则 `&self` 的生命周期被赋给所有的输出生命周期**

#### 方法中的生命周期

为具有生命周期的结构体实现方法时，我们使用的语法跟泛型参数语法很相似：

```rust
#![allow(unused)]
fn main() {
    struct ImportantExcerpt<'a> {
        part: &'a str,
    }

    impl<'a> ImportantExcerpt<'a> {
        fn level(&self) -> i32 {
            3
        }
    }
}
```

#### 静态生命周期

Rust 中有一个非常特殊的生命周期，那就是 `'static`，拥有该生命周期的引用可以和整个程序活得一样久。

总结如下：

-   生命周期 `'static` 意味着能和程序活得一样久，例如字符串字面量和特征对象
-   实在遇到解决不了的生命周期标注问题，可以尝试 `T: 'static`，有时候它会给你奇迹

### 3.1.2 深入生命周期[TODO]

### 3.1.3 &'static 和 T: 'static

`'static` 在 Rust 中是相当常见的，例如字符串字面值就具有 `'static` 生命周期:

```rust
fn main() {
    let mark_twain: &str = "Samuel Clemens";
    print_author(mark_twain);
}
fn print_author(author: &'static str) {
    println!("{}", author);
}
```

`'static` 的另一种使用场景:

```rust
use std::fmt::Display;
fn main() {
    let mark_twain = "Samuel Clemens";
    print(&mark_twain);
}

fn print<T: Display + 'static>(message: &T) {
    println!("{}", message);
}
```

#### &'static

`&'static` 对于生命周期有着非常强的要求：一个引用必须要活得跟剩下的程序一样久，才能被标注为 `&'static`。

**`&'static` 生命周期针对的仅仅是引用，而不是持有该引用的变量，对于变量来说，还是要遵循相应的作用域规则。**

####  T: 'static

#### static 到底针对谁？

-   是 `&'static` 这个引用还是该引用指向的数据活得跟程序一样久呢？

    **答案是引用指向的数据**，而引用本身是要遵循其作用域范围的

#### 总结

经验之谈，可以这么来:

-   如果你需要添加 `&'static` 来让代码工作，那很可能是设计上出问题了
-   如果你希望满足和取悦编译器，那就使用 `T: 'static`，很多时候它都能解决问题

## 3.2 函数式编程：闭包、迭代器

### 3.2.1 闭包 `Closure`

闭包：匿名函数，可以赋值给变量或作为参数传递给其他函数，允许捕获调用者作用域中的值。

```rust
fn main() {
   let x = 1;
   let sum = |y| x + y;

    assert_eq!(3, sum(2));
}
```

#### 使用闭包简化代码

通过将函数赋值给某一变量，可以快速调整对此函数的使用。

#### 闭包实现

闭包的形式定义：

```rust
|param1, param2,...| {
    语句1;
    语句2;
    返回表达式
}
or
|param1| 返回表达式
```

#### 闭包类型推导

多数情况下，不需要显式声明类型。

同一功能的函数与闭包实现形式：

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

闭包的类型推导中，**当编译器推导出一种类型后，它就会一直使用该类型**。

```rust
#![allow(unused)]
fn main() {
    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
}
output:
error[E0308]: mismatched types
  --> src/main.rs:13:29
   |
13 |     let n = example_closure(5);
   |                             ^- help: try using a conversion method: `.to_string()`
   |                             |
   |                             expected struct `String`, found integer

For more information about this error, try `rustc --explain E0308`.
```

#### 结构体中的闭包

假设我们要实现一个简易缓存，功能是获取一个值，然后将其缓存起来，那么可以这样设计：

-   一个闭包用于获取值
-   一个变量，用于存储该值

可以使用结构体来代表缓存对象，最终设计如下：

```rust
struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    query: T,
    value: Option<u32>,
}
```

>     Fn 特征不仅仅适用于闭包，还适用于函数

```rust
impl<T> Cacher<T>
where
    T: Fn(u32) -> u32,
{
    fn new(query: T) -> Cacher<T> {
        Cacher {
            query,
            value: None,
        }
    }

    // 先查询缓存值 `self.value`，若不存在，则调用 `query` 加载
    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.query)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
}
```

#### 捕获作用域中的值

```rust
fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```

`x` 并不是闭包 `equal_to_x` 的参数，但是它依然可以去使用 `x`，因为 `equal_to_x` 在 `x` 的作用域范围内。

##### 闭包对内存的影响

当闭包从环境中捕获一个值时，会**分配内存**去存储这些值。

#### 三种 `Fn` 特征

1.   `FnOnce`，该类型的闭包会拿走被捕获变量的所有权。`Once` 顾名思义，说明该闭包只能运行一次：

     ```rust
     fn fn_once<F>(func: F)
     where
         F: FnOnce(usize) -> bool,
     {
         println!("{}", func(3));
         println!("{}", func(4));
     }
     
     fn main() {
         let x = vec![1, 2, 3];
         fn_once(|z| z == x.len())
     }
     ```

     >   **仅**实现 `FnOnce` 特征的闭包在调用时会转移所有权。

2.   `FnMut`，它以可变借用的方式捕获了环境中的值:

     ```rust
     fn main() {
         let mut s = String::new();
     
         let update_string = |str| s.push_str(str);
         update_string("hello");
     
         println!("{:?}", s);
     }
     ```

3.   `Fn` 特征，它以不可变借用的方式捕获环境中的值:

     ```rust
     fn main() {
         let mut s = String::new();
     
         let update_string =  |str| s.push_str(str);
     
         exec(update_string);
     
         println!("{:?}",s);
     }
     
     fn exec<'a, F: Fn(&'a str)>(mut f: F)  {
         f("hello")
     }
     ```

##### `move` 和 `Fn`

**一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量**

##### 三种 `Fn` 的关系

一个闭包并不仅仅实现某一种 `Fn` 特征，规则如下：

-   所有的闭包都自动实现了 `FnOnce` 特征，因此任何一个闭包都至少可以被调用一次
-   没有移出所捕获变量的所有权的闭包自动实现了 `FnMut` 特征
-   不需要对捕获变量进行改变的闭包自动实现了 `Fn` 特征

```rust
fn main() {
    let s = String::new();

    let update_string = || println!("{}", s);

    exec(update_string);
    exec1(update_string);
    exec2(update_string);
}

fn exec<F: FnOnce()>(f: F) {
    f()
}

fn exec1<F: FnMut()>(mut f: F) {
    f()
}

fn exec2<F: Fn()>(f: F) {
    f()
}
```

#### 闭包作为函数返回值

```rust
fn factory(x:i32) -> Box<dyn Fn(i32) -> i32> {
    let num = 5;

    if x > 1{
        Box::new(move |x| x + num)
    } else {
        Box::new(move |x| x - num)
    }
}
```

### 3.2.2 迭代器 `Iterator`

#### `For` 与迭代器

区别在于是否通过**索引**来访问集合

`Rust`中数组实现了 `IntoIterator`特征，通过`for`语法糖将该特征的数组转换为迭代器。

```rust
#![allow(unused)]
fn main() {
    let arr = [1, 2, 3];
    for v in arr {
        println!("{}", v);
    }
}
```

 `IntoIterator` 特征有一个 `into_iter` 方法，可以显式的把数组转换成迭代器：

```rust
#![allow(unused)]
fn main() {
    let arr = [1, 2, 3];
    for v in arr.into_iter() {
        println!("{}", v);
    }
}
```

#### 惰性初始化

Rust中迭代器是惰性的。

#### `IntoIterator`特征

##### `into_iter`, `iter`, `iter_mut`

-   `into_iter` 会夺走所有权
-   `iter` 是借用
-   `iter_mut` 是可变借用

##### `Iterator` 和 `IntoIterator` 的区别

-   `Iterator` 就是迭代器特征，只有实现了它才能称为迭代器，才能调用 `next`
-   `IntoIterator` 强调的是某一个类型如果实现了该特征，它可以通过 `into_iter`，`iter` 等方法变成一个迭代器

#### 消费者与适配器

##### 消费者适配器

迭代器上的某个方法 `A` 在其内部调用了 `next` 方法，那么 `A` 就被称为**消费性适配器**

```rust
fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);

    // v1_iter 是借用了 v1，因此 v1 可以照常使用
    println!("{:?}", v1);

    // 以下代码会报错，因为 `sum` 拿到了迭代器 `v1_iter` 的所有权
    // println!("{:?}",v1_iter);
}
```

##### 迭代器适配器

迭代器适配器，顾名思义，会返回一个新的迭代器。

迭代器适配器是惰性的，意味着你**需要一个消费者适配器来收尾，最终将迭代器转换成一个具体的值**：

```rust
#![allow(unused)]
fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
}
```

## 3.3 深入类型

### 3.3.1 `newtype` 和类型别名

#### `newtype`

使用**元组结构体**的方式将已有的类型包裹起来：`Meters（u32）`，`Meters` 就是一个`newtype`。

好处：

-   自定义类型可以让我们给出更有意义和可读性的类型名
-   对于某些场景，只有 `newtype` 可以很好地解决
-   隐藏内部类型的细节

#### 为外部类型实现外部特征

在外部类型上实现外部特征必须使用 `newtype` 的方式，否则你就得遵循孤儿规则：要为类型 `A` 实现特征 `T`，那么 `A` 或者 `T` 必须至少有一个在当前的作用范围内。

使用 `newtype` 对标注库类型 `Vec` 实现 `Display` 特征：

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}
output:
w = [hello, world]
```

#### 隐藏内部细节

使用 `newtype` 对外隐藏内部细节：

```rust
struct Meters(u32);

fn main() {
    let i: u32 = 2;
    assert_eq!(i.pow(2), 4);

    let n = Meters(i);
    // 下面的代码将报错，因为`Meters`类型上没有`pow`方法
    // assert_eq!(n.pow(2), 4);
}
```

### 类型别名

更传统的方式来创建新类型：类型别名

```rust
type Meters = u32
```

**类型别名并不是一个独立的全新的类型，而是某一个类型的别名**。

### 3.3.2 `Sized` 和不定长类型`DST`

-   定长类型( sized )，这些类型的大小在编译时是已知的
-   不定长类型( unsized )，与定长类型相反，它的大小只有到了程序运行时才能动态获知，这种类型又被称之为 DST

#### 动态大小类型 `DST`

**因为编译器无法在编译期获知类型大小，若你试图在代码中直接使用 DST 类型，将无法通过编译**。

试图创建动态大小数组:

```rust
#![allow(unused)]
fn main() {
    fn my_function(n: usize) {
        let array = [123; n];
    }
}
```

切片:

`str`:

```rust
#![allow(unused)]
fn main() {
    // error
    let s1: str = "Hello there!";
    let s2: str = "How's it going?";

    // ok
    let s3: &str = "on?";
}
```

因此，将动态数据固定化的秘诀就是使用引用指向这些动态数据，然后在引用中存储相关的内存位置、长度等信息。

特征对象:

```rust
#![allow(unused)]
fn main() {
    fn foobar_1(thing: &dyn MyThing) {} // OK
    fn foobar_2(thing: Box<dyn MyThing>) {} // OK
    fn foobar_3(thing: MyThing) {} // ERROR!
}
```

总结：只能间接使用的 DST

Rust 中常见的 `DST` 类型有: `str`、`[T]`、`dyn Trait`，**它们都无法单独被使用，必须要通过引用或者 `Box` 来间接使用** 。

#### `Size` 特征

Rust如何保证泛型参数是固定大小类型的？

编译器自动帮我们加上了 `Sized` 特征：**所有在编译时就能知道其大小的类型，都会自动实现 `Sized` 特征**。

**每一个特征都是一个可以通过名称来引用的动态大小类型**。因此如果想把特征作为具体的类型来传递给函数，你必须将其转换成一个特征对象：诸如 `&dyn Trait` 或者 `Box<dyn Trait>` (还有 `Rc<dyn Trait>`)这些引用类型。

想在泛型函数中使用动态数据类型怎么办？可以使用 `?Sized` 特征：

```rust
#![allow(unused)]
fn main() {
    fn generic<T: ?Sized>(t: &T) {
        // --snip--
    }
}
```

`?Sized` 特征用于表明类型 `T` 是固定大小的类型，或者动态大小的类型。还有一点要注意的是，函数参数类型从 `T` 变成了 `&T`，因为 `T` 可能是动态大小的，因此需要用一个固定大小的指针(引用)来包裹它。

#### `Box<str>`

```rust
#![allow(unused)]
fn main() {
    let s1: Box<str> = "Hello there!".into();
}
```

### 3.4 智能指针

智能指针：通过比引用更复杂的数据结构，包含比引用更多的信息，例如元数据，当前长度，最大可用长度等。

### 3.4.1 `Box` 堆对象分配

 `Box<T>` 允许你将一个值分配到堆上，然后在栈上保留一个智能指针指向堆上的数据。

#### `Rust` 中的堆栈

Rust 堆上对象有一个特殊之处，它们都拥有一个所有者，因此受所有权规则的限制：当赋值时，发生的是所有权的转移（只需浅拷贝栈上的引用或智能指针即可）：

```rust
fn main() {
    let b = foo("world");
    println!("{}", b);
}

fn foo(x: &str) -> String {
    let a = "Hello, ".to_string() + x;
    a
}
```

#### `Box` 使用场景

`Box` 特性：

-   特意将数据分配在堆上
-   数据较大时，又不想在转移所有权时进行数据拷贝
-   类型的大小在编译期无法确定，但是我们又需要固定大小的类型时
-   特征对象，用于说明对象实现了一个特征，而不是某个特定的类型

##### 使用 `Box` 将数据存储在堆上

使用 `Deref` 解引用获取指针所指对象的值。

```rust
fn main() {
    let a = Box::new(3);
    println!("a = {}", a); // a = 3

    // 下面一行代码将报错
    // let b = a + 1; // cannot add `{integer}` to `Box<{integer}>`
}
```

##### 避免栈上数据的拷贝

当栈上数据转移所有权时，实际上是把数据拷贝了一份，最终新旧变量各自拥有不同的数据，因此所有权并未转移。

```rust
fn main() {
    // 在栈上创建一个长度为1000的数组
    let arr = [0; 1000];
    // 将arr所有权转移arr1，由于 `arr` 分配在栈上，因此这里实际上是直接重新深拷贝了一份数据
    let arr1 = arr;

    // arr 和 arr1 都拥有各自的栈上数组，因此不会报错
    println!("{:?}", arr.len());
    println!("{:?}", arr1.len());

    // 在堆上创建一个长度为1000的数组，然后使用一个智能指针指向它
    let arr = Box::new([0; 1000]);
    // 将堆上数组的所有权转移给 arr1，由于数据在堆上，因此仅仅拷贝了智能指针的结构体，底层数据并没有被拷贝
    // 所有权顺利转移给 arr1，arr 不再拥有所有权
    let arr1 = arr;
    println!("{:?}", arr1.len());
    // 由于 arr 不再拥有底层数组的所有权，因此下面代码将报错
    // println!("{:?}", arr.len());
}
```

##### 将动态大小类型变为 `Sized` 固定大小类型

##### 特征对象

实现不同类型组成的数组只有两个办法：枚举和特征对象。

```rust
trait Draw {
    fn draw(&self);
}

struct Button {
    id: u32,
}
impl Draw for Button {
    fn draw(&self) {
        println!("这是屏幕上第{}号按钮", self.id)
    }
}

struct Select {
    id: u32,
}

impl Draw for Select {
    fn draw(&self) {
        println!("这个选择框贼难用{}", self.id)
    }
}

fn main() {
    let elems: Vec<Box<dyn Draw>> = vec![Box::new(Button { id: 1 }), Box::new(Select { id: 2 })];

    for e in elems {
        e.draw()
    }
}
output:
这是屏幕上第1号按钮
这个选择框贼难用2
```

#### `Box::leak`

它可以消费掉 `Box` 并且强制目标值从内存中泄漏。

使用场景：
如果你需要一个在运行期初始化的值，但是可以全局有效，也就是和整个程序活得一样久，那么就可以使用 `Box::leak`。

### 3.4.2 `Deref` 解引用

#### 通过 `*` 获取引用背后的值

对常规引用使用 `*` 操作符，就可以通过解引用的方式获取到内存地址对应的数据值：

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

#### 智能指针解引用

智能指针通过实现 `Deref` 特征，自定义解引用结果：

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

fn main() {
    let y = MyBox::new(5);

    assert_eq!(5, *y);
}
```

需要注意的是：

-   在 `Deref` 特征中声明了关联类型 `Target`，在之前章节中介绍过，关联类型主要是为了提升代码可读性
-   `deref` 返回的是一个常规引用，可以被 `*` 进行解引用

#### `*` 背后原理

智能指针 `Box` 解引用的背后：

```rust
*(y.deref())
```

首先调用 `deref()` 获取常规引用，再通过 `*` 对常规引用解引用，从而获取目标值。

#### 函数和方法中的隐式 `Deref` 转换

若一个类型实现了 `Deref` 特征，那它的引用在传给函数或方法时，会根据参数签名来决定是否进行隐式的 `Deref` 转换：

```rust
fn main() {
    let s = String::from("hello world");
    display(&s)
}

fn display(s: &str) {
    println!("{}", s);
}
```

以上代码有几点值得注意：

-   `String` 实现了 `Deref` 特征，可以在需要时自动被转换为 `&str` 类型
-   `&s` 是一个 `&String` 类型，当它被传给 `display` 函数时，自动通过 `Deref` 转换成了 `&str`
-   必须使用 `&s` 的方式来触发 `Deref`(仅引用类型的实参才会触发自动解引用)

##### 连续的隐式 `Deref` 转换

`Deref` 可以支持连续的隐式转换，直到找到适合的形式为止：

```rust
fn main() {
    let s = MyBox::new(String::from("hello world"));
    display(&s)
}

fn display(s: &str) {
    println!("{}", s);
}
```

#### `Deref` 规则总结

#### 三种 `Deref` 转换

Rust 还支持将一个可变的引用转换成另一个可变的引用以及将一个可变引用转换成不可变的引用，规则如下：

-   当 `T: Deref<Target=U>`，可以将 `&T` 转换成 `&U`，也就是我们之前看到的例子
-   当 `T: DerefMut<Target=U>`，可以将 `&mut T` 转换成 `&mut U`
-   当 `T: Deref<Target=U>`，可以将 `&mut T` 转换成 `&U`

