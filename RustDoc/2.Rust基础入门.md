## 2.1 变量绑定与解构

### 为何 `Rust` 选择了手动设定变量的可变性

一般来说，变量一旦创建，要么可变（灵活）或者不可变（安全），而 `Rust` 的变量两者都具有。

### 变量绑定

```rust
let a = "akira"
```

### 变量可变性

`Rust` 的变量在默认情况下是***不可变的***，可以通过 `mut` 关键字让变量变为***可变的***

编写代码：

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

保存并运行：

```bash
$ cargo run          
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
```

具体的错误原因是 `cannot assign twice to immutable variable x`

修改代码：

```rust
let mut x = 5;
```

再次运行：

```bash
$ cargo run
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

可变还是不可变，更多的还是取决于你的使用场景：灵活与安全之间的抉择。可变变量最大的好处就是使用上的灵活性和性能上的提升。

### 变量解构

`let` 表达式用于变量的绑定，进行复杂变量的解构。

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,不可变; b = false，可变
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

### 解构式赋值

```rust
let (a, b, c, d, e);

    (a, b) = (1, 2);
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
```

>   这种使用方式跟之前的 `let` 保持了一致性，但是 `let` 会重新绑定，而这里仅仅是对之前绑定的变量进行再赋值。
>
>   使用 `+=` 的赋值语句还不支持解构式赋值

### 变量与常量之间的差异

-   常量不允许使用 `mut`。**常量不仅仅默认不可变，而且自始至终不可变**，因为常量在编译完成后，已经确定它的值。
-   常量使用 `const` 关键字而不是 `let` 关键字来声明，并且值的类型**必须**标注。

### 变量遮蔽(shadowing)

`Rust` 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的:

```rust
fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;

    {
        // 在当前的花括号作用域内，对之前的x进行遮蔽
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```

运行：

```bash
$ cargo run
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `./variables`
var shadowing
The value of x in the inner scope is: 12
The value of x is: 6
```

>   多次的`let`声明了多个同名变量，使用更多内存
>
>   `mut`只是修改同一内存地址上的值，不会发生内存对象的再分配，性能要更好

变量遮蔽的作用：
如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），可以重复的使用变量名字

## 2.2 基本类型

-   数值类型: 有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数
-   字符串：字符串字面量和字符串切片 `&str`
-   布尔类型： `true`和`false`
-   字符类型: 表示单个 Unicode 字符，存储为 4 个字节
-   单元类型: 即 `()` ，其唯一的值也是 `()`

`Rust` 是一门**静态类型**语言，也就是编译器必须在编译期知道我们所有变量的类型，但这不意味着你需要为每个变量指定类型，因为 **Rust 编译器很聪明，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型**

### 2.2.1 数值类型

#### 整数类型

类型定义的形式统一为：`有无符号 + 类型大小(位数)`

 eg: 

有符号类型：i8，i16，i32（默认类型），i64，i128，isize（视架构而定）

无符号类型：u8，u16，u32，u64，u128，usize（视架构而定）

>整型溢出：
>
>debug 模式下会检测数值溢出，造成编译失败（`panic`）
>
>--release 模式下不会检测溢出，Rust 会按照补码循环溢出（*two’s complement wrapping*）的规则处理
>
>要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：
>
>-   使用 `wrapping_*` 方法在所有模式下都按照补码循环溢出规则处理，例如 `wrapping_add`
>-   如果使用 `checked_*` 方法时发生溢出，则返回 `None` 值
>-   使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
>-   使用 `saturating_*` 方法使值达到最小值或最大值

#### 浮点类型

两种基本类型： `f32` 和 `f64`（默认）

#### NaN

对于数学上未定义的结果，使用`NaN`来处理

可以使用 `is_nan()` 等方法，可以用来判断一个数值是否是 `NaN` 

#### 序列（`Range`）

序列只允许用于数字或字符类型，原因是：它们可以连续。

eg:

```rust
for i in 1..=5 {
    println!("{}",i);
}
output: 
1
2
3
4
5
```

#### 总结：

-   **Rust 拥有相当多的数值类型**. 熟悉类型占用的字节数与范围
-   **类型转换必须是显式的**
-   **Rust 的数值上可以使用方法**. 例如你可以用以下方法来将 `13.14` 取整：`13.14_f32.round()`









