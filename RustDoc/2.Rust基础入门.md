## 2.1 å˜é‡ç»‘å®šä¸è§£æ„

### ä¸ºä½• `Rust` é€‰æ‹©äº†æ‰‹åŠ¨è®¾å®šå˜é‡çš„å¯å˜æ€§

ä¸€èˆ¬æ¥è¯´ï¼Œå˜é‡ä¸€æ—¦åˆ›å»ºï¼Œè¦ä¹ˆå¯å˜ï¼ˆçµæ´»ï¼‰æˆ–è€…ä¸å¯å˜ï¼ˆå®‰å…¨ï¼‰ï¼Œè€Œ `Rust` çš„å˜é‡ä¸¤è€…éƒ½å…·æœ‰ã€‚

### å˜é‡ç»‘å®š

```rust
let a = "akira"
```

### å˜é‡å¯å˜æ€§

`Rust` çš„å˜é‡åœ¨é»˜è®¤æƒ…å†µä¸‹æ˜¯***ä¸å¯å˜çš„***ï¼Œå¯ä»¥é€šè¿‡ `mut` å…³é”®å­—è®©å˜é‡å˜ä¸º***å¯å˜çš„***

ç¼–å†™ä»£ç ï¼š

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

ä¿å­˜å¹¶è¿è¡Œï¼š

```bash
$ cargo run          
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
```

å…·ä½“çš„é”™è¯¯åŸå› æ˜¯ `cannot assign twice to immutable variable x`

ä¿®æ”¹ä»£ç ï¼š

```rust
let mut x = 5;
```

å†æ¬¡è¿è¡Œï¼š

```bash
$ cargo run
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

å¯å˜è¿˜æ˜¯ä¸å¯å˜ï¼Œæ›´å¤šçš„è¿˜æ˜¯å–å†³äºä½ çš„ä½¿ç”¨åœºæ™¯ï¼šçµæ´»ä¸å®‰å…¨ä¹‹é—´çš„æŠ‰æ‹©ã€‚å¯å˜å˜é‡æœ€å¤§çš„å¥½å¤„å°±æ˜¯ä½¿ç”¨ä¸Šçš„çµæ´»æ€§å’Œæ€§èƒ½ä¸Šçš„æå‡ã€‚

### å˜é‡è§£æ„

`let` è¡¨è¾¾å¼ç”¨äºå˜é‡çš„ç»‘å®šï¼Œä¹Ÿå¯ä»¥è¿›è¡Œå¤æ‚å˜é‡çš„è§£æ„ã€‚

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,ä¸å¯å˜; b = falseï¼Œå¯å˜
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

### è§£æ„å¼èµ‹å€¼

```rust
let (a, b, c, d, e);

    (a, b) = (1, 2);
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
```

>   è¿™ç§ä½¿ç”¨æ–¹å¼è·Ÿä¹‹å‰çš„ `let` ä¿æŒäº†ä¸€è‡´æ€§ï¼Œä½†æ˜¯ `let` ä¼šé‡æ–°ç»‘å®šï¼Œè€Œè¿™é‡Œä»…ä»…æ˜¯å¯¹ä¹‹å‰ç»‘å®šçš„å˜é‡è¿›è¡Œå†èµ‹å€¼ã€‚
>
>   ä½¿ç”¨ `+=` çš„èµ‹å€¼è¯­å¥è¿˜ä¸æ”¯æŒè§£æ„å¼èµ‹å€¼

### å˜é‡ä¸å¸¸é‡ä¹‹é—´çš„å·®å¼‚

-   å¸¸é‡ä¸å…è®¸ä½¿ç”¨ `mut`ã€‚**å¸¸é‡ä¸ä»…ä»…é»˜è®¤ä¸å¯å˜ï¼Œè€Œä¸”è‡ªå§‹è‡³ç»ˆä¸å¯å˜**ï¼Œå› ä¸ºå¸¸é‡åœ¨ç¼–è¯‘å®Œæˆåï¼Œå·²ç»ç¡®å®šå®ƒçš„å€¼ã€‚
-   å¸¸é‡ä½¿ç”¨ `const` å…³é”®å­—è€Œä¸æ˜¯ `let` å…³é”®å­—æ¥å£°æ˜ï¼Œå¹¶ä¸”å€¼çš„ç±»å‹**å¿…é¡»**æ ‡æ³¨ã€‚

### å˜é‡é®è”½(shadowing)

`Rust` å…è®¸å£°æ˜ç›¸åŒçš„å˜é‡åï¼Œåœ¨åé¢å£°æ˜çš„å˜é‡ä¼šé®è”½æ‰å‰é¢å£°æ˜çš„:

```rust
fn main() {
    let x = 5;
    // åœ¨mainå‡½æ•°çš„ä½œç”¨åŸŸå†…å¯¹ä¹‹å‰çš„xè¿›è¡Œé®è”½
    let x = x + 1;

    {
        // åœ¨å½“å‰çš„èŠ±æ‹¬å·ä½œç”¨åŸŸå†…ï¼Œå¯¹ä¹‹å‰çš„xè¿›è¡Œé®è”½
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```

è¿è¡Œï¼š

```bash
$ cargo run
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `./variables`
var shadowing
The value of x in the inner scope is: 12
The value of x is: 6
```

>   å¤šæ¬¡çš„`let`å£°æ˜äº†å¤šä¸ªåŒåå˜é‡ï¼Œä½¿ç”¨æ›´å¤šå†…å­˜
>
>   `mut`åªæ˜¯ä¿®æ”¹åŒä¸€å†…å­˜åœ°å€ä¸Šçš„å€¼ï¼Œä¸ä¼šå‘ç”Ÿå†…å­˜å¯¹è±¡çš„å†åˆ†é…ï¼Œæ€§èƒ½è¦æ›´å¥½

å˜é‡é®è”½çš„ä½œç”¨ï¼š
å¦‚æœä½ åœ¨æŸä¸ªä½œç”¨åŸŸå†…æ— éœ€å†ä½¿ç”¨ä¹‹å‰çš„å˜é‡ï¼ˆåœ¨è¢«é®è”½åï¼Œæ— æ³•å†è®¿é—®åˆ°ä¹‹å‰çš„åŒåå˜é‡ï¼‰ï¼Œå¯ä»¥é‡å¤çš„ä½¿ç”¨å˜é‡åå­—

## 2.2 åŸºæœ¬ç±»å‹

-   æ•°å€¼ç±»å‹: æœ‰ç¬¦å·æ•´æ•° (`i8`, `i16`, `i32`, `i64`, `isize`)ã€ æ— ç¬¦å·æ•´æ•° (`u8`, `u16`, `u32`, `u64`, `usize`) ã€æµ®ç‚¹æ•° (`f32`, `f64`)ã€ä»¥åŠæœ‰ç†æ•°ã€å¤æ•°
-   å­—ç¬¦ä¸²ï¼šå­—ç¬¦ä¸²å­—é¢é‡å’Œå­—ç¬¦ä¸²åˆ‡ç‰‡ `&str`
-   å¸ƒå°”ç±»å‹ï¼š `true`å’Œ`false`
-   å­—ç¬¦ç±»å‹: è¡¨ç¤ºå•ä¸ª Unicode å­—ç¬¦ï¼Œå­˜å‚¨ä¸º 4 ä¸ªå­—èŠ‚
-   å•å…ƒç±»å‹: å³ `()` ï¼Œå…¶å”¯ä¸€çš„å€¼ä¹Ÿæ˜¯ `()`

`Rust` æ˜¯ä¸€é—¨**é™æ€ç±»å‹**è¯­è¨€ï¼Œä¹Ÿå°±æ˜¯ç¼–è¯‘å™¨å¿…é¡»åœ¨ç¼–è¯‘æœŸçŸ¥é“æˆ‘ä»¬æ‰€æœ‰å˜é‡çš„ç±»å‹ï¼Œä½†è¿™ä¸æ„å‘³ç€ä½ éœ€è¦ä¸ºæ¯ä¸ªå˜é‡æŒ‡å®šç±»å‹ï¼Œå› ä¸º **Rust ç¼–è¯‘å™¨å¾ˆèªæ˜ï¼Œå®ƒå¯ä»¥æ ¹æ®å˜é‡çš„å€¼å’Œä¸Šä¸‹æ–‡ä¸­çš„ä½¿ç”¨æ–¹å¼æ¥è‡ªåŠ¨æ¨å¯¼å‡ºå˜é‡çš„ç±»å‹**

### 2.2.1 æ•°å€¼ç±»å‹

#### æ•´æ•°ç±»å‹

ç±»å‹å®šä¹‰çš„å½¢å¼ç»Ÿä¸€ä¸ºï¼š`æœ‰æ— ç¬¦å· + ç±»å‹å¤§å°(ä½æ•°)`

 eg: 

æœ‰ç¬¦å·ç±»å‹ï¼ši8ï¼Œi16ï¼Œi32ï¼ˆé»˜è®¤ç±»å‹ï¼‰ï¼Œi64ï¼Œi128ï¼Œisizeï¼ˆè§†æ¶æ„è€Œå®šï¼‰

æ— ç¬¦å·ç±»å‹ï¼šu8ï¼Œu16ï¼Œu32ï¼Œu64ï¼Œu128ï¼Œusizeï¼ˆè§†æ¶æ„è€Œå®šï¼‰

>æ•´å‹æº¢å‡ºï¼š
>
>debug æ¨¡å¼ä¸‹ä¼šæ£€æµ‹æ•°å€¼æº¢å‡ºï¼Œé€ æˆç¼–è¯‘å¤±è´¥ï¼ˆ`panic`ï¼‰
>
>--release æ¨¡å¼ä¸‹ä¸ä¼šæ£€æµ‹æº¢å‡ºï¼ŒRust ä¼šæŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºï¼ˆ*twoâ€™s complement wrapping*ï¼‰çš„è§„åˆ™å¤„ç†
>
>è¦æ˜¾å¼å¤„ç†å¯èƒ½çš„æº¢å‡ºï¼Œå¯ä»¥ä½¿ç”¨æ ‡å‡†åº“é’ˆå¯¹åŸå§‹æ•°å­—ç±»å‹æä¾›çš„è¿™äº›æ–¹æ³•ï¼š
>
>-   ä½¿ç”¨ `wrapping_*` æ–¹æ³•åœ¨æ‰€æœ‰æ¨¡å¼ä¸‹éƒ½æŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºè§„åˆ™å¤„ç†ï¼Œä¾‹å¦‚ `wrapping_add`
>-   å¦‚æœä½¿ç”¨ `checked_*` æ–¹æ³•æ—¶å‘ç”Ÿæº¢å‡ºï¼Œåˆ™è¿”å› `None` å€¼
>-   ä½¿ç”¨ `overflowing_*` æ–¹æ³•è¿”å›è¯¥å€¼å’Œä¸€ä¸ªæŒ‡ç¤ºæ˜¯å¦å­˜åœ¨æº¢å‡ºçš„å¸ƒå°”å€¼
>-   ä½¿ç”¨ `saturating_*` æ–¹æ³•ä½¿å€¼è¾¾åˆ°æœ€å°å€¼æˆ–æœ€å¤§å€¼

#### æµ®ç‚¹ç±»å‹

ä¸¤ç§åŸºæœ¬ç±»å‹ï¼š `f32` å’Œ `f64`ï¼ˆé»˜è®¤ï¼‰

#### NaN

å¯¹äºæ•°å­¦ä¸Šæœªå®šä¹‰çš„ç»“æœï¼Œä½¿ç”¨`NaN`æ¥å¤„ç†

å¯ä»¥ä½¿ç”¨ `is_nan()` ç­‰æ–¹æ³•ï¼Œå¯ä»¥ç”¨æ¥åˆ¤æ–­ä¸€ä¸ªæ•°å€¼æ˜¯å¦æ˜¯ `NaN` 

#### åºåˆ—ï¼ˆ`Range`ï¼‰

åºåˆ—åªå…è®¸ç”¨äºæ•°å­—æˆ–å­—ç¬¦ç±»å‹ï¼ŒåŸå› æ˜¯ï¼šå®ƒä»¬å¯ä»¥è¿ç»­ã€‚

eg:

```rust
for i in 1..=5 {
    println!("{}",i);
}
output: 
1
2
3
4
5
```

#### æ€»ç»“ï¼š

-   **Rust æ‹¥æœ‰ç›¸å½“å¤šçš„æ•°å€¼ç±»å‹**. ç†Ÿæ‚‰ç±»å‹å ç”¨çš„å­—èŠ‚æ•°ä¸èŒƒå›´
-   **ç±»å‹è½¬æ¢å¿…é¡»æ˜¯æ˜¾å¼çš„**
-   **Rust çš„æ•°å€¼ä¸Šå¯ä»¥ä½¿ç”¨æ–¹æ³•**. ä¾‹å¦‚ä½ å¯ä»¥ç”¨ä»¥ä¸‹æ–¹æ³•æ¥å°† `13.14` å–æ•´ï¼š`13.14_f32.round()`



### 2.2.2 å­—ç¬¦ã€å¸ƒå°”ã€å•å…ƒç±»å‹

#### å­—ç¬¦ç±»å‹

Rust çš„å­—ç¬¦ä¸ä»…ä»…æ˜¯ `ASCII`ï¼Œæ‰€æœ‰çš„ `Unicode` å€¼éƒ½å¯ä»¥ä½œä¸º Rust å­—ç¬¦ã€‚

```rust
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let g = 'å›½';
    let heart_eyed_cat = 'ğŸ˜»';
}
```

>   Rust çš„å­—ç¬¦åªèƒ½ç”¨ `''` æ¥è¡¨ç¤ºï¼Œ `""` æ˜¯ç•™ç»™å­—ç¬¦ä¸²çš„

#### å¸ƒå°”ï¼ˆboolï¼‰

å¸ƒå°”ç±»å‹æœ‰ä¸¤ä¸ªå¯èƒ½çš„å€¼ï¼š`true` å’Œ `false`ï¼Œå¤§å°ä¸º `1` ä¸ªå­—èŠ‚ï¼š

```rust
fn main() {
    let t = true;

    let f: bool = false; // ä½¿ç”¨ç±»å‹æ ‡æ³¨,æ˜¾å¼æŒ‡å®šfçš„ç±»å‹

    if f {
        println!("è¿™æ˜¯æ®µæ¯«æ— æ„ä¹‰çš„ä»£ç ");
    }
}
```

#### å•å…ƒç±»å‹

å•å…ƒç±»å‹å°±æ˜¯ `()`ï¼Œå”¯ä¸€çš„å€¼ä¹Ÿæ˜¯ `()` ã€‚

`main` å‡½æ•°å°±è¿”å›è¿™ä¸ªå•å…ƒç±»å‹ `()`

æ²¡æœ‰è¿”å›å€¼çš„å‡½æ•°åœ¨ Rust ä¸­æ˜¯æœ‰å•ç‹¬çš„å®šä¹‰çš„ï¼š`å‘æ•£å‡½æ•°`

### 2.2.3 è¯­å¥å’Œè¡¨è¾¾å¼

Rust çš„å‡½æ•°ä½“æ˜¯ç”±ä¸€ç³»åˆ—è¯­å¥ç»„æˆï¼Œæœ€åç”±ä¸€ä¸ªè¡¨è¾¾å¼æ¥è¿”å›å€¼ï¼Œä¾‹å¦‚ï¼š

```rust
fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // è¯­å¥
    let y = y + 5; // è¯­å¥
    x + y // è¡¨è¾¾å¼
}
```

è¡¨è¾¾å¼ä¼šåœ¨æ±‚å€¼åè¿”å›ä¸€ä¸ªå€¼

### 2.2.4 å‡½æ•°

![img](https://s2.loli.net/2022/03/10/nD7mvPi43Xpe9Of.png)

#### å‡½æ•°è¦ç‚¹

-   å‡½æ•°åå’Œå˜é‡åä½¿ç”¨ `snake case` ä¾‹å¦‚ `fn add_two() -> {}`
-   å‡½æ•°çš„ä½ç½®å¯ä»¥éšä¾¿æ”¾ï¼ŒRust ä¸å…³å¿ƒæˆ‘ä»¬åœ¨å“ªé‡Œå®šä¹‰äº†å‡½æ•°ï¼Œåªè¦æœ‰å®šä¹‰å³å¯
-   æ¯ä¸ªå‡½æ•°å‚æ•°éƒ½éœ€è¦æ ‡æ³¨ç±»å‹

#### å‡½æ•°è¿”å›

å‡½æ•°çš„è¿”å›å€¼å°±æ˜¯å‡½æ•°ä½“æœ€åä¸€æ¡è¡¨è¾¾å¼çš„è¿”å›å€¼ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ `return` æå‰è¿”å›ã€‚

#### `Rust` ä¸­ç‰¹æ®Šçš„è¿”å›ç±»å‹

##### æ— è¿”å›å€¼ `()`

å•å…ƒç±»å‹ `()`ï¼Œæ˜¯ä¸€ä¸ªé›¶é•¿åº¦çš„å…ƒç»„ã€‚å®ƒæ²¡å•¥ä½œç”¨ï¼Œä½†æ˜¯å¯ä»¥ç”¨æ¥è¡¨è¾¾ä¸€ä¸ªå‡½æ•°æ²¡æœ‰è¿”å›å€¼ï¼š

-   å‡½æ•°æ²¡æœ‰è¿”å›å€¼ï¼Œé‚£ä¹ˆè¿”å›ä¸€ä¸ª `()`
-   é€šè¿‡ `;` ç»“å°¾çš„è¡¨è¾¾å¼è¿”å›ä¸€ä¸ª `()`

##### æ°¸ä¸è¿”å›çš„å‡½æ•° `!`

ç”¨ `!` ä½œå‡½æ•°è¿”å›ç±»å‹çš„æ—¶å€™ï¼Œè¡¨ç¤ºè¯¥å‡½æ•°æ°¸ä¸è¿”å›

eg:

```rust
fn forever() -> ! {
  loop {
    //...
  };
}
```

## 2.3 æ‰€æœ‰æƒä¸å€Ÿç”¨â­ï¸

### 2.3.1 æ‰€æœ‰æƒ

å¦‚ä½•ç®¡ç†ç³»ç»Ÿå†…å­˜ï¼š

-   **åƒåœ¾å›æ”¶æœºåˆ¶(GC)**ï¼Œåœ¨ç¨‹åºè¿è¡Œæ—¶ä¸æ–­å¯»æ‰¾ä¸å†ä½¿ç”¨çš„å†…å­˜ï¼Œå…¸å‹ä»£è¡¨ï¼šJavaã€Go
-   **æ‰‹åŠ¨ç®¡ç†å†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾**, åœ¨ç¨‹åºä¸­ï¼Œé€šè¿‡å‡½æ•°è°ƒç”¨çš„æ–¹å¼æ¥ç”³è¯·å’Œé‡Šæ”¾å†…å­˜ï¼Œå…¸å‹ä»£è¡¨ï¼šC++
-   **é€šè¿‡æ‰€æœ‰æƒæ¥ç®¡ç†å†…å­˜**ï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶ä¼šæ ¹æ®ä¸€ç³»åˆ—è§„åˆ™è¿›è¡Œæ£€æŸ¥

é€šè¿‡æ‰€æœ‰æƒæ¥ç®¡ç†å†…å­˜æ£€æŸ¥åªå‘ç”Ÿåœ¨ç¼–è¯‘æœŸï¼Œè¿è¡ŒæœŸä¸ä¼šæœ‰æ€§èƒ½æŸè€—

#### æ‰€æœ‰æƒåŸåˆ™

1.  Rust ä¸­æ¯ä¸€ä¸ªå€¼éƒ½ `æœ‰ä¸”åªæœ‰` ä¸€ä¸ªæ‰€æœ‰è€…(å˜é‡)
2.  å½“æ‰€æœ‰è€…(å˜é‡)ç¦»å¼€ä½œç”¨åŸŸèŒƒå›´æ—¶ï¼Œè¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒ(drop)

å¯¹äºç®€å•ç±»å‹çš„å˜é‡ï¼šæ ˆä¸Šç›´æ¥å°†æ•°æ®æ‹·è´ï¼Œèµ‹å€¼ç»™æ–°å˜é‡

å¯¹äºå¤æ‚ç±»å‹çš„å˜é‡ï¼šå¤æ‚å¯¹è±¡çš„æŒ‡é’ˆèµ‹å€¼ç»™æ–°çš„å˜é‡ä¼šå¯¼è‡´æ—§çš„æŒ‡é’ˆå˜é‡å¤±æ•ˆ => å¯¹æ­¤å¤æ‚å¯¹è±¡çš„æ‰€æœ‰æƒè½¬ç§»

>   ä»¥ `String` ä¸ºä¾‹æ€è€ƒï¼š
>
>   `String` ç±»å‹æŒ‡å‘äº†ä¸€ä¸ªå †ä¸Šçš„ç©ºé—´ï¼Œå­˜å‚¨ç€å®ƒçš„çœŸå®æ•°æ®, å¯¹äºä»£ç ä¸­çš„ `let s2 = s1` åˆ†æˆä¸¤ç§æƒ…å†µè®¨è®ºï¼š
>
>   1.  æ‹·è´ `String` å’Œå­˜å‚¨åœ¨å †ä¸Šçš„å­—èŠ‚æ•°ç»„ å¦‚æœè¯¥è¯­å¥æ˜¯æ‹·è´æ‰€æœ‰æ•°æ®(æ·±æ‹·è´)ï¼Œé‚£ä¹ˆæ— è®ºæ˜¯ `String` æœ¬èº«è¿˜æ˜¯åº•å±‚çš„å †ä¸Šæ•°æ®ï¼Œéƒ½ä¼šè¢«å…¨éƒ¨æ‹·è´ï¼Œè¿™å¯¹äºæ€§èƒ½è€Œè¨€ä¼šé€ æˆéå¸¸å¤§çš„å½±å“
>   2.  åªæ‹·è´ `String` æœ¬èº« è¿™æ ·çš„æ‹·è´éå¸¸å¿«ï¼Œå› ä¸ºåœ¨ 64 ä½æœºå™¨ä¸Šå°±æ‹·è´äº† `8å­—èŠ‚çš„æŒ‡é’ˆ`ã€`8å­—èŠ‚çš„é•¿åº¦`ã€`8å­—èŠ‚çš„å®¹é‡`ï¼Œæ€»è®¡ 24 å­—èŠ‚ï¼Œä½†æ˜¯å¸¦æ¥äº†æ–°çš„é—®é¢˜ï¼Œæ ¹æ®æ‰€æœ‰æƒè§„åˆ™ï¼Œå…¶ä¸­ä¸€æ¡ï¼š**ä¸€ä¸ªå€¼åªå…è®¸æœ‰ä¸€ä¸ªæ‰€æœ‰è€…**ï¼Œè€Œç°åœ¨è¿™ä¸ªå€¼ï¼ˆå †ä¸Šçš„çœŸå®å­—ç¬¦ä¸²æ•°æ®ï¼‰æœ‰äº†ä¸¤ä¸ªæ‰€æœ‰è€…ï¼š`s1` å’Œ `s2`ã€‚å‡å®šä¸€ä¸ªå€¼å¯ä»¥æ‹¥æœ‰ä¸¤ä¸ªæ‰€æœ‰è€…ï¼Œå°±ä¼šå¯¼è‡´ **äºŒæ¬¡é‡Šæ”¾ï¼ˆdouble freeï¼‰** çš„é”™è¯¯ã€‚

eg:

```rust
#![allow(unused)]
fn main() {
  let s1 = String::from("hello");
  let s2 = s1;
	println!("{}, world!", s1);
}
output:
error[E0382]: use of moved value: `s1`
 --> src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
```

â—ï¸æ­¤æ—¶å†æ€è€ƒ **å˜é‡ç»‘å®š** ä¸ **å˜é‡èµ‹å€¼ **è¯­ä¹‰ä¸Šçš„åŒºåˆ«

#### å…‹éš†ï¼ˆæ·±æ‹·è´ï¼‰

**Rust æ°¸è¿œä¹Ÿä¸ä¼šè‡ªåŠ¨åˆ›å»ºæ•°æ®çš„ â€œæ·±æ‹·è´â€**  => ä»»ä½•**è‡ªåŠ¨**çš„å¤åˆ¶éƒ½ä¸æ˜¯æ·±æ‹·è´

 ä½¿ç”¨ `clone()` è¿›è¡Œæ·±æ‹·è´

eg:

```rust
#![allow(unused)]
fn main() {
  let s1 = String::from("hello");
  let s2 = s1.clone();

  println!("s1 = {}, s2 = {}", s1, s2);
}
output:
s1 = hello, s2 = hello
```

#### æ‹·è´ï¼ˆæµ…æ‹·è´ï¼‰

æµ…æ‹·è´åªå‘ç”Ÿåœ¨æ ˆ

Rust æœ‰ä¸€ä¸ªå«åš `Copy` çš„ç‰¹å¾ï¼Œå¯ä»¥ç”¨åœ¨ç±»ä¼¼æ•´å‹è¿™æ ·åœ¨æ ˆä¸­å­˜å‚¨çš„ç±»å‹ã€‚å¦‚æœä¸€ä¸ªç±»å‹æ‹¥æœ‰ `Copy` ç‰¹å¾ï¼Œä¸€ä¸ªæ—§çš„å˜é‡åœ¨è¢«èµ‹å€¼ç»™å…¶ä»–å˜é‡åä»ç„¶å¯ç”¨ã€‚

 **ä»»ä½•åŸºæœ¬ç±»å‹çš„ç»„åˆå¯ä»¥ `Copy` ï¼Œä¸éœ€è¦åˆ†é…å†…å­˜æˆ–æŸç§å½¢å¼èµ„æºçš„ç±»å‹æ˜¯å¯ä»¥ `Copy` çš„**ã€‚å¦‚ä¸‹æ˜¯ä¸€äº› `Copy` çš„ç±»å‹ï¼š

-   æ‰€æœ‰æ•´æ•°ç±»å‹ï¼Œæ¯”å¦‚ `u32`ã€‚
-   å¸ƒå°”ç±»å‹ï¼Œ`bool`ï¼Œå®ƒçš„å€¼æ˜¯ `true` å’Œ `false`ã€‚
-   æ‰€æœ‰æµ®ç‚¹æ•°ç±»å‹ï¼Œæ¯”å¦‚ `f64`ã€‚
-   å­—ç¬¦ç±»å‹ï¼Œ`char`ã€‚
-   å…ƒç»„ï¼Œå½“ä¸”ä»…å½“å…¶åŒ…å«çš„ç±»å‹ä¹Ÿéƒ½æ˜¯ `Copy` çš„æ—¶å€™ã€‚æ¯”å¦‚ï¼Œ`(i32, i32)` æ˜¯ `Copy` çš„ï¼Œä½† `(i32, String)` å°±ä¸æ˜¯ã€‚
-   å¼•ç”¨ç±»å‹

#### å‡½æ•°ä¼ å€¼ä¸è¿”å›

å°†å€¼ä¼ é€’ç»™å‡½æ•°ï¼Œä¸€æ ·ä¼šå‘ç”Ÿ `ç§»åŠ¨` æˆ–è€… `å¤åˆ¶`ï¼Œå°±è·Ÿ `let` è¯­å¥ä¸€æ ·ã€‚

```rust
fn main() {
    let s = String::from("hello");  // s è¿›å…¥ä½œç”¨åŸŸ

    takes_ownership(s);             // s çš„å€¼ç§»åŠ¨åˆ°å‡½æ•°é‡Œ ...
                                    // ... æ‰€ä»¥åˆ°è¿™é‡Œä¸å†æœ‰æ•ˆ

    let x = 5;                      // x è¿›å…¥ä½œç”¨åŸŸ

    makes_copy(x);                  // x åº”è¯¥ç§»åŠ¨å‡½æ•°é‡Œï¼Œ
                                    // ä½† i32 æ˜¯ Copy çš„ï¼Œæ‰€ä»¥åœ¨åé¢å¯ç»§ç»­ä½¿ç”¨ x

} // è¿™é‡Œ, x å…ˆç§»å‡ºäº†ä½œç”¨åŸŸï¼Œç„¶åæ˜¯ sã€‚ä½†å› ä¸º s çš„å€¼å·²è¢«ç§»èµ°ï¼Œ
  // æ‰€ä»¥ä¸ä¼šæœ‰ç‰¹æ®Šæ“ä½œ

fn takes_ownership(some_string: String) { // some_string è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_string);
} // è¿™é‡Œï¼Œsome_string ç§»å‡ºä½œç”¨åŸŸå¹¶è°ƒç”¨ `drop` æ–¹æ³•ã€‚å ç”¨çš„å†…å­˜è¢«é‡Šæ”¾

fn makes_copy(some_integer: i32) { // some_integer è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_integer);
} // è¿™é‡Œï¼Œsome_integer ç§»å‡ºä½œç”¨åŸŸã€‚ä¸ä¼šæœ‰ç‰¹æ®Šæ“ä½œ
```

åŒæ ·çš„ï¼Œå‡½æ•°è¿”å›å€¼ä¹Ÿæœ‰æ‰€æœ‰æƒï¼Œä¾‹å¦‚:

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership å°†è¿”å›å€¼
                                        // ç§»ç»™ s1

    let s2 = String::from("hello");     // s2 è¿›å…¥ä½œç”¨åŸŸ

    let s3 = takes_and_gives_back(s2);  // s2 è¢«ç§»åŠ¨åˆ°
                                        // takes_and_gives_back ä¸­,
                                        // å®ƒä¹Ÿå°†è¿”å›å€¼ç§»ç»™ s3
} // è¿™é‡Œ, s3 ç§»å‡ºä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒã€‚s2 ä¹Ÿç§»å‡ºä½œç”¨åŸŸï¼Œä½†å·²è¢«ç§»èµ°ï¼Œ
  // æ‰€ä»¥ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿã€‚s1 ç§»å‡ºä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ

fn gives_ownership() -> String {             // gives_ownership å°†è¿”å›å€¼ç§»åŠ¨ç»™
                                             // è°ƒç”¨å®ƒçš„å‡½æ•°

    let some_string = String::from("hello"); // some_string è¿›å…¥ä½œç”¨åŸŸ.

    some_string                              // è¿”å› some_string å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
}

// takes_and_gives_back å°†ä¼ å…¥å­—ç¬¦ä¸²å¹¶è¿”å›è¯¥å€¼
fn takes_and_gives_back(a_string: String) -> String { // a_string è¿›å…¥ä½œç”¨åŸŸ

    a_string  // è¿”å› a_string å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
}
```

### 2.3.2 å¼•ç”¨ä¸å€Ÿç”¨

å¦‚æœä»…ä»…ä½¿ç”¨å˜é‡çš„æŒ‡é’ˆæˆ–è€…å¼•ç”¨ï¼Œè€Œéè·å¾—æ‰€æœ‰æƒï¼Œå¯ä»¥é€šè¿‡ `å€Ÿç”¨(Borrowing)` ï¼Œ**è·å–å˜é‡çš„å¼•ç”¨ï¼Œç§°ä¹‹ä¸ºå€Ÿç”¨(borrowing)**ã€‚

#### å¼•ç”¨ä¸è§£å¼•ç”¨

```rust
fn main() {
    let x = 5;
    let y = &x; // è·å–æŒ‡å‘xçš„å¼•ç”¨

    assert_eq!(5, x);
    assert_eq!(5, *y); // é€šè¿‡ `*` è§£å¼•ç”¨ï¼Œå¾—åˆ°yæ‰€æŒ‡å‘çš„æ•°æ® 
}
```

#### ä¸å¯å˜å¼•ç”¨

ä¸‹é¢çš„ä»£ç ï¼Œæˆ‘ä»¬ç”¨ `s1` çš„å¼•ç”¨ä½œä¸ºå‚æ•°ä¼ é€’ç»™ `calculate_length` å‡½æ•°ï¼Œè€Œä¸æ˜¯æŠŠ `s1` çš„æ‰€æœ‰æƒè½¬ç§»ç»™è¯¥å‡½æ•°ï¼š

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
output:
The length of 'hello' is 5.
```

å˜åŒ–è¿‡ç¨‹ï¼š

![&String s pointing at String s1](https://s2.loli.net/2022/03/13/bnqGQHhCDvy2pF7.jpg)

#### å¯å˜å¼•ç”¨

é€šè¿‡ `mut` å…³é”®å­—ï¼Œå¯ä»¥æ“ä½œå¼•ç”¨æ‰€æŒ‡å‘çš„æ•°æ®

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
    println!("s is :{}", s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
output:
s is :hello, world
```

å®ƒæœ‰ä¸€ä¸ªå¾ˆå¤§çš„é™åˆ¶ï¼š **åŒä¸€ä½œç”¨åŸŸï¼Œç‰¹å®šæ•°æ®åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨**ï¼š

```rust
#![allow(unused)]
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
}
output:
error[E0499]: cannot borrow `s` as mutable more than once at a time
  --> src/main.rs:10:14
   |
9  |     let r1 = &mut s;
   |              ------ first mutable borrow occurs here
10 |     let r2 = &mut s;
   |              ^^^^^^ second mutable borrow occurs here
11 | 
12 |     println!("{}, {}", r1, r2);
   |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `hello_world` due to previous error
```

##### å¯å˜å¼•ç”¨ä¸ä¸å¯å˜å¼•ç”¨ä¸èƒ½åŒæ—¶å­˜åœ¨

```rust
#![allow(unused)]
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // æ²¡é—®é¢˜
    let r2 = &s; // æ²¡é—®é¢˜
    let r3 = &mut s; // å¤§é—®é¢˜

    println!("{}, {}, and {}", r1, r2, r3);
}
```

#### æ‚¬å‚å¼•ç”¨(Dangling References)

æ‚¬å‚å¼•ç”¨ä¹Ÿå«åšæ‚¬å‚æŒ‡é’ˆï¼Œæ„æ€ä¸ºæŒ‡é’ˆæŒ‡å‘æŸä¸ªå€¼åï¼Œè¿™ä¸ªå€¼è¢«é‡Šæ”¾æ‰äº†ï¼Œè€ŒæŒ‡é’ˆä»ç„¶å­˜åœ¨ï¼Œå…¶æŒ‡å‘çš„å†…å­˜å¯èƒ½ä¸å­˜åœ¨ä»»ä½•å€¼æˆ–å·²è¢«å…¶å®ƒå˜é‡é‡æ–°ä½¿ç”¨ã€‚

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
output:
error[E0106]: missing lifetime specifier
  --> src/main.rs:11:16
   |
11 | fn dangle() -> &String {
   |                ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
   |
11 | fn dangle() -> &'static String {
   |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `hello_world` due to previous error
```

#### å€Ÿç”¨è§„åˆ™æ€»ç»“

æ€»çš„æ¥è¯´ï¼Œå€Ÿç”¨è§„åˆ™å¦‚ä¸‹ï¼š

-   åŒä¸€æ—¶åˆ»ï¼Œä½ åªèƒ½æ‹¥æœ‰è¦ä¹ˆä¸€ä¸ªå¯å˜å¼•ç”¨, è¦ä¹ˆä»»æ„å¤šä¸ªä¸å¯å˜å¼•ç”¨
-   å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„

## 2.4 å¤åˆç±»å‹

å¤åˆç±»å‹æ˜¯ç”±å…¶å®ƒç±»å‹ç»„åˆè€Œæˆçš„ï¼Œæœ€å…¸å‹çš„å°±æ˜¯ç»“æ„ä½“ `struct` å’Œæšä¸¾ `enum`ã€‚

### 2.4.1 å­—ç¬¦ä¸²å’Œåˆ‡ç‰‡

Will it be success?

```rust
fn main() {
    let my_name = "Akira";
    greet(my_name);
}

fn greet(name: String) {
    println!("Hello, {}!", name);
}
output:
error[E0308]: mismatched types
 --> src/main.rs:3:11
  |
3 |     greet(my_name);
  |           ^^^^^^^- help: try using a conversion method: `.to_string()`
  |           |
  |           expected struct `String`, found `&str`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `string` due to previous error
```

#### åˆ‡ç‰‡ï¼ˆsliceï¼‰

åˆ‡ç‰‡å…è®¸ä½ å¼•ç”¨é›†åˆä¸­éƒ¨åˆ†è¿ç»­çš„å…ƒç´ åºåˆ—ï¼Œè€Œä¸æ˜¯å¼•ç”¨æ•´ä¸ªé›†åˆã€‚

åˆ›å»ºåˆ‡ç‰‡çš„è¯­æ³•ï¼Œä½¿ç”¨æ–¹æ‹¬å·åŒ…æ‹¬çš„ä¸€ä¸ªåºåˆ—: **[å¼€å§‹ç´¢å¼•..ç»ˆæ­¢ç´¢å¼•]**ï¼Œæ˜¯è¿™æ˜¯ä¸€ä¸ª `å·¦é—­å³å¼€åŒºé—´`ã€‚

eg:

```rust
#![allow(unused_variables)]
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
    println!("{} {}", hello, world);
}
output:
hello world
```

åˆ‡ç‰‡è§£æï¼š

<img src="https://s2.loli.net/2022/03/14/nhHQXYtfuUKOdsA.jpg" alt="img" style="zoom:20%;" />

```rust
let s = String::from("hello");

// è·å–å‰ä¸¤ä¸ªå­—èŠ‚æ•°æ®
let slice = &s[0..2]; 
let slice = &s[..2];

// è·å–å®Œæ•´å­—èŠ‚æ•°æ®
let slice = &s[0..len];
let slice = &s[..];
```

>   å¯¹å­—ç¬¦ä¸²è¿›è¡Œåˆ‡ç‰‡ï¼Œéœ€è¦æ³¨æ„å­—ç¬¦ä¸²çš„ç¼–ç ï¼Œå¦åˆ™å¯¼è‡´ç¨‹åºä¼šç›´æ¥å´©æºƒé€€å‡º
>   eg:
>
>   ```rust
>   #![allow(unused)]
>   fn main() {
>       let s = "ä¸­å›½äºº";
>       let a = &s[0..2];
>       println!("{}", a);
>   }
>   output:
>   thread 'main' panicked at 'byte index 2 is not a char boundary; it is inside 'ä¸­' (bytes 0..3) of `ä¸­å›½äºº`'
>   ```

#### å­—ç¬¦ä¸²å­—é¢é‡æ˜¯åˆ‡ç‰‡

å­—ç¬¦ä¸²å˜é‡çš„ç±»å‹æ˜¯ `&str`

eg:`let s: &str = "Hello, world!";`

#### ä»€ä¹ˆæ˜¯å­—ç¬¦ä¸²ï¼Ÿ

**`Rust` ä¸­å­—ç¬¦ä¸² `UTF-8` ç¼–ç ï¼Œä¹Ÿå°±æ˜¯å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦æ‰€å çš„å­—èŠ‚æ•°æ˜¯å˜åŒ–çš„(1 - 4)**ã€‚

`String` æ˜¯ä¸€ä¸ªå¯å¢é•¿ã€å¯æ”¹å˜ä¸”å…·æœ‰æ‰€æœ‰æƒçš„ UTF-8 ç¼–ç å­—ç¬¦ä¸²

**å½“ Rust ç”¨æˆ·æåˆ°å­—ç¬¦ä¸²æ—¶ï¼Œå¾€å¾€æŒ‡çš„å°±æ˜¯ `String` ç±»å‹å’Œ `&str` å­—ç¬¦ä¸²åˆ‡ç‰‡ç±»å‹ï¼Œè¿™ä¸¤ä¸ªç±»å‹éƒ½æ˜¯ UTF-8 ç¼–ç **ã€‚

##### æ“ä½œå­—ç¬¦ä¸²

```rust
fn main() {
    // åˆ›å»ºä¸€ä¸ªç©ºString
    let mut s = String::new();
    // å°†&strç±»å‹çš„"hello,world"æ·»åŠ åˆ°sä¸­
    s.push_str("hello,world");
    // å°†å­—ç¬¦'!'æ¨å…¥sä¸­
    s.push('!');
    // æœ€åsçš„å†…å®¹æ˜¯"hello,world!"
    assert_eq!(s,"hello,world!");

    // ä»ç°æœ‰çš„&stråˆ‡ç‰‡åˆ›å»ºStringç±»å‹
    let mut s = "hello,world".to_string();
    // å°†å­—ç¬¦'!'æ¨å…¥sä¸­
    s.push('!');
    // æœ€åsçš„å†…å®¹æ˜¯"hello,world!"
    assert_eq!(s,"hello,world!");

    // ä»ç°æœ‰çš„&stråˆ‡ç‰‡åˆ›å»ºStringç±»å‹
    // Stringä¸&stréƒ½æ˜¯UTF-8ç¼–ç ï¼Œå› æ­¤æ”¯æŒä¸­æ–‡
    let mut s = String::from("ä½ å¥½,ä¸–ç•Œ");
    // å°†å­—ç¬¦'!'æ¨å…¥sä¸­
    s.push('!');
    // æœ€åsçš„å†…å®¹æ˜¯"ä½ å¥½,ä¸–ç•Œ!"
    assert_eq!(s,"ä½ å¥½,ä¸–ç•Œ!");

    let s1 = String::from("hello,");
    let s2 = String::from("world!");
    // åœ¨ä¸‹å¥ä¸­ï¼Œs1çš„æ‰€æœ‰æƒè¢«è½¬ç§»èµ°äº†ï¼Œå› æ­¤åé¢ä¸èƒ½å†ä½¿ç”¨s1
    let s3 = s1 + &s2;
    assert_eq!(s3,"hello,world!");
    // ä¸‹é¢çš„è¯­å¥å¦‚æœå»æ‰æ³¨é‡Šï¼Œå°±ä¼šæŠ¥é”™
    // println!("{}",s1);
}
```

##### String ä¸ &str çš„è½¬æ¢

1.   `&str` ç±»å‹ç”Ÿæˆ `String` ç±»å‹

     -   `String::from("hello,world")`
     -   `"hello,world".to_string()`

2.   `String` ç±»å‹è½¬ä¸º `&str` ç±»å‹

     ```rust
     fn main() {
         let s = String::from("hello,world!");
         say_hello(&s);
         say_hello(&s[..]);
         say_hello(s.as_str());
     }
     
     fn say_hello(s: &str) {
         println!("{}",s);
     }
     ```

##### å­—ç¬¦ä¸²ç´¢å¼•

å­—ç¬¦ä¸²çš„åº•å±‚æ˜¯[ `u8` ]ï¼Œä¸€ä¸ªå­—èŠ‚æ•°ç»„ã€‚å¯¹äºä¸åŒç±»å‹å­—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œç´¢å¼•ä¸‹çš„å­—ç¬¦å¯èƒ½æ— æ„ä¹‰ã€‚

```rust
#![allow(unused)]
fn main() {
    let s1 = String::from("hello");
    let h = s1[0];
}
output:
error[E0277]: the type `String` cannot be indexed by `{integer}`
  --> src/main.rs:63:13
   |
63 |     let h = s1[0];
   |             ^^^^^ `String` cannot be indexed by `{integer}`
   |
   = help: the trait `Index<{integer}>` is not implemented for `String`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `string` due to previous error
```

>   å¦ä¸€ä¸ªåŸå› å¯¼è‡´äº† Rust ä¸å…è®¸å»ç´¢å¼•å­—ç¬¦ä¸²ï¼šå› ä¸ºç´¢å¼•æ“ä½œï¼Œæˆ‘ä»¬æ€»æ˜¯æœŸæœ›å®ƒçš„æ€§èƒ½è¡¨ç°æ˜¯ O(1)ï¼Œç„¶è€Œå¯¹äº `String` ç±»å‹æ¥è¯´ï¼Œæ— æ³•ä¿è¯è¿™ä¸€ç‚¹ï¼Œå› ä¸º Rust å¯èƒ½éœ€è¦ä» 0 å¼€å§‹å»éå†å­—ç¬¦ä¸²æ¥å®šä½åˆæ³•çš„å­—ç¬¦ã€‚

##### æ“ä½œ `UTF8` å­—ç¬¦ä¸²

ä»¥ Unicode å­—ç¬¦çš„æ–¹å¼éå†å­—ç¬¦ä¸²ï¼Œæœ€å¥½çš„åŠæ³•æ˜¯ä½¿ç”¨ `chars` æ–¹æ³•ï¼š

```rust
#![allow(unused)]
fn main() {
    for c in "ä¸­å›½äºº".chars() {
        println!("{}", c);
    }
}
output:
ä¸­
å›½
äºº
```

è¿”å›å­—ç¬¦ä¸²çš„åº•å±‚å­—èŠ‚æ•°ç»„è¡¨ç°å½¢å¼ï¼š

```rust
#![allow(unused)]
fn main() {
    for b in "ä¸­å›½äºº".bytes() {
        println!("{}", b);
    }
}
output:
228
184
173
229
155
189
228
186
186
```

##### å­—ç¬¦ä¸²æ·±åº¦å‰–æ

ä¸ºå•¥ `String` å¯å˜ï¼Œè€Œå­—ç¬¦ä¸²å­—é¢å€¼ `str` å´ä¸å¯ä»¥ï¼Ÿ

å­—ç¬¦ä¸²å­—é¢å€¼åœ¨ç¼–è¯‘æ—¶ç›´æ¥ç¡¬ç¼–ç è¿›å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼Œå¿«é€Ÿä¸”é«˜æ•ˆã€‚

`String` ç±»å‹çš„å­˜åœ¨ä¸ºäº†æ”¯æŒä¸€ä¸ªå¯å˜çš„æ–‡æœ¬ä¸²ï¼Œéœ€è¦åœ¨å †ä¸Šåˆ†é…æœªçŸ¥å¤§å°çš„å†…å­˜æ¥å­˜æ”¾ã€‚

åœ¨ç¨‹åºè¿è¡Œæ—¶ï¼š

-   é¦–å…ˆå‘æ“ä½œç³»ç»Ÿè¯·æ±‚å†…å­˜æ¥å­˜æ”¾ `String` å¯¹è±¡
-   åœ¨ä½¿ç”¨å®Œæˆåï¼Œå°†å†…å­˜é‡Šæ”¾ï¼Œå½’è¿˜ç»™æ“ä½œç³»ç»Ÿ

### 2.4.2 å…ƒç»„

å…ƒç»„æ˜¯ç”±å¤šç§ç±»å‹ç»„åˆåˆ°ä¸€èµ·å½¢æˆçš„ï¼Œé•¿åº¦å›ºå®šï¼Œé¡ºåºå›ºå®šã€‚

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
```

ä½¿ç”¨æ¨¡å¼åŒ¹é…æˆ–è€… `.` æ“ä½œç¬¦æ¥è·å–å…ƒç»„ä¸­çš„å€¼

```rust
let tup = (500, 6.4, 1);
let (x, y, z) = tup;

-----------------------
let x: (i32, f64, u8) = (500, 6.4, 1);

let five_hundred = x.0;

let six_point_four = x.1;

let one = x.2;
```

### 2.4.3 ç»“æ„ä½“

ä¸€ä¸ªç»“æ„ä½“æœ‰å‡ éƒ¨åˆ†ç»„æˆï¼š

-   é€šè¿‡å…³é”®å­— `struct` å®šä¹‰
-   ä¸€ä¸ªæ¸…æ™°æ˜ç¡®çš„ç»“æ„ä½“ `åç§°`
-   å‡ ä¸ªæœ‰åå­—çš„ç»“æ„ä½“ `å­—æ®µ`

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

#### åˆ›å»ºç»“æ„ä½“å®ä¾‹

```rust
let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
};
```

â—ï¸æ³¨æ„

1.  åˆå§‹åŒ–å®ä¾‹æ—¶ï¼Œ**æ¯ä¸ªå­—æ®µ**éƒ½éœ€è¦è¿›è¡Œåˆå§‹åŒ–
2.  åˆå§‹åŒ–æ—¶çš„å­—æ®µé¡ºåº**ä¸éœ€è¦**å’Œç»“æ„ä½“å®šä¹‰æ—¶çš„é¡ºåºä¸€è‡´

é€šè¿‡ `.` æ“ä½œç¬¦å³å¯æ“ä½œç»“æ„ä½“å®ä¾‹å†…éƒ¨çš„å­—æ®µå€¼

```rust
let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

user1.email = String::from("anotheremail@example.com");
```

â—ï¸æ³¨æ„

åªæœ‰ç»“æ„ä½“å®ä¾‹å£°æ˜ä¸ºå¯å˜çš„ï¼Œæ‰èƒ½ä¿®æ”¹å…¶ä¸­çš„å­—æ®µï¼Œä¸æ”¯æŒç»“æ„ä½“å†…éƒ¨å­—æ®µå¯å˜

#### ç®€åŒ–ç»“æ„ä½“åˆ›å»º

```rust
eg1:
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
eg2:
// å½“å‡½æ•°å‚æ•°å’Œç»“æ„ä½“å­—æ®µåŒåæ—¶ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ç¼©ç•¥
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
```

#### ç»“æ„ä½“æ›´æ–°è¯­æ³•

æ ¹æ®å·²æœ‰çš„ç»“æ„ä½“å®ä¾‹ï¼Œåˆ›å»ºæ–°çš„ç»“æ„ä½“å®ä¾‹:

```rust
Method1ï¼š
let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };

Method2ï¼š
let user2 = User {
        email: String::from("another@example.com"),
  			// .. è¯­æ³•è¡¨æ˜å‡¡æ˜¯æˆ‘ä»¬æ²¡æœ‰æ˜¾ç¤ºå£°æ˜çš„å­—æ®µå…¨éƒ¨ä» user1 ä¸­è‡ªåŠ¨è·å–
  			// ..user1 å¿…é¡»åœ¨ç»“æ„ä½“çš„å°¾éƒ¨ä½¿ç”¨
        ..user1
    };
```

>   ç»“æ„ä½“æ›´æ–°è¯­æ³•è·Ÿèµ‹å€¼è¯­å¥ `=` éå¸¸ç›¸åƒï¼Œå› æ­¤åœ¨ä¸Šé¢ä»£ç ä¸­ï¼Œ`user1` çš„éƒ¨åˆ†å­—æ®µæ‰€æœ‰æƒè¢«è½¬ç§»åˆ° `user2` ä¸­ï¼š`username` å­—æ®µå‘ç”Ÿäº†æ‰€æœ‰æƒè½¬ç§»ï¼Œä½œä¸ºç»“æœï¼Œ`user1` æ— æ³•å†è¢«ä½¿ç”¨ã€‚ä½†æ˜¯å¹¶ä¸ä»£è¡¨ `user1` å†…éƒ¨çš„å…¶å®ƒå­—æ®µä¸èƒ½è¢«ç»§ç»­ä½¿ç”¨ï¼Œä¾‹å¦‚ï¼š
>
>   ```rust
>   fn main() {
>       let user1 = User {
>           email: String::from("someone@example.com"),
>           username: String::from("someusername123"),
>           active: true,
>           sign_in_count: 1,
>       };
>       let user2 = User {
>           active: user1.active,
>           username: user1.username,
>           email: String::from("another@example.com"),
>           sign_in_count: user1.sign_in_count,
>       };
>       println!("{}", user1.active);
>       // ä¸‹é¢è¿™è¡Œä¼šæŠ¥é”™
>       println!("{:?}", user1);
>   }
>   output:
>   error[E0382]: borrow of partially moved value: `user1`
>     --> src/main.rs:68:22
>      |
>   62 |         username: user1.username,
>      |                   -------------- value partially moved here
>   ...
>   68 |     println!("{:?}", user1);
>      |                      ^^^^^ value borrowed here after partial move
>      |
>      = note: partial move occurs because `user1.username` has type `String`, which does not implement the `Copy` trait
>      = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)
>   
>   For more information about this error, try `rustc --explain E0382`.
>   warning: `struct-demo` (bin "struct-demo") generated 1 warning
>   error: could not compile `struct-demo` due to previous error; 1 warning emitted
>   ```

#### ç»“æ„ä½“çš„å†…å­˜æ’åˆ—

code exampleï¼š

```rust
#[derive(Debug)]
 struct File {
   name: String,
   data: Vec<u8>,
 }

 fn main() {
   let f1 = File {
     name: String::from("f1.txt"),
     data: Vec::new(),
   };

   let f1_name = &f1.name;
   let f1_length = &f1.data.len();

   println!("{:?}", f1);
   println!("{} is {} bytes long", f1_name, f1_length);
 }
```

å†…å­˜æ’åˆ—å¦‚å›¾ï¼š

![image-20220315133114763](https://s2.loli.net/2022/03/15/coq7TkyLaYuJVfW.png)

#### å…ƒç»„ç»“æ„ä½“

ç»“æ„ä½“çš„å­—æ®µå¯ä»¥æ²¡æœ‰åç§°ï¼š

```rust
#[allow(unused)]
fn main() {
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```

#### å•å…ƒç»“æ„ä½“

å¦‚æœä½ å®šä¹‰ä¸€ä¸ªç±»å‹ï¼Œä½†æ˜¯ä¸å…³å¿ƒè¯¥ç±»å‹çš„å†…å®¹, åªå…³å¿ƒå®ƒçš„è¡Œä¸ºæ—¶ï¼Œå°±å¯ä»¥ä½¿ç”¨ `å•å…ƒç»“æ„ä½“`ï¼š

```rust
#[allow(unused)]
fn main() {
    struct AlwaysEqual;

    let subject = AlwaysEqual;

    // æˆ‘ä»¬ä¸å…³å¿ƒ AlwaysEqual çš„å­—æ®µæ•°æ®ï¼Œåªå…³å¿ƒå®ƒçš„è¡Œä¸ºï¼Œå› æ­¤å°†å®ƒå£°æ˜ä¸ºå•å…ƒç»“æ„ä½“ï¼Œç„¶åå†ä¸ºå®ƒå®ç°æŸä¸ªç‰¹å¾
    impl SomeTrait for AlwaysEqual {}
}
```

#### ç»“æ„ä½“æ•°æ®çš„æ‰€æœ‰æƒ

å¦‚æœæƒ³è®©ç»“æ„ä½“ä»å…¶å®ƒå¯¹è±¡å€Ÿç”¨æ•°æ®ï¼Œå°±å¿…é¡»åŠ å…¥**ç”Ÿå‘½å‘¨æœŸ** ï¼Œä¿è¯ç»“æ„ä½“çš„ä½œç”¨èŒƒå›´å°äºå€Ÿç”¨æ•°æ®çš„ä½œç”¨èŒƒå›´ã€‚

```rust
struct User {
    username: &str,
    email: &str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: "someone@example.com",
        username: "someusername123",
        active: true,
        sign_in_count: 1,
    };
}
```

