## 2.1 å˜é‡ç»‘å®šä¸è§£æ„

### ä¸ºä½• `Rust` é€‰æ‹©äº†æ‰‹åŠ¨è®¾å®šå˜é‡çš„å¯å˜æ€§

ä¸€èˆ¬æ¥è¯´ï¼Œå˜é‡ä¸€æ—¦åˆ›å»ºï¼Œè¦ä¹ˆå¯å˜ï¼ˆçµæ´»ï¼‰æˆ–è€…ä¸å¯å˜ï¼ˆå®‰å…¨ï¼‰ï¼Œè€Œ `Rust` çš„å˜é‡ä¸¤è€…éƒ½å…·æœ‰ã€‚

### å˜é‡ç»‘å®š

```rust
let a = "akira"
```

### å˜é‡å¯å˜æ€§

`Rust` çš„å˜é‡åœ¨é»˜è®¤æƒ…å†µä¸‹æ˜¯***ä¸å¯å˜çš„***ï¼Œå¯ä»¥é€šè¿‡ `mut` å…³é”®å­—è®©å˜é‡å˜ä¸º***å¯å˜çš„***

ç¼–å†™ä»£ç ï¼š

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

ä¿å­˜å¹¶è¿è¡Œï¼š

```bash
$ cargo run          
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
```

å…·ä½“çš„é”™è¯¯åŸå› æ˜¯ `cannot assign twice to immutable variable x`

ä¿®æ”¹ä»£ç ï¼š

```rust
let mut x = 5;
```

å†æ¬¡è¿è¡Œï¼š

```bash
$ cargo run
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

å¯å˜è¿˜æ˜¯ä¸å¯å˜ï¼Œæ›´å¤šçš„è¿˜æ˜¯å–å†³äºä½ çš„ä½¿ç”¨åœºæ™¯ï¼šçµæ´»ä¸å®‰å…¨ä¹‹é—´çš„æŠ‰æ‹©ã€‚å¯å˜å˜é‡æœ€å¤§çš„å¥½å¤„å°±æ˜¯ä½¿ç”¨ä¸Šçš„çµæ´»æ€§å’Œæ€§èƒ½ä¸Šçš„æå‡ã€‚

### å˜é‡è§£æ„

`let` è¡¨è¾¾å¼ç”¨äºå˜é‡çš„ç»‘å®šï¼Œä¹Ÿå¯ä»¥è¿›è¡Œå¤æ‚å˜é‡çš„è§£æ„ã€‚

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,ä¸å¯å˜; b = falseï¼Œå¯å˜
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

### è§£æ„å¼èµ‹å€¼

```rust
let (a, b, c, d, e);

    (a, b) = (1, 2);
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
```

>   è¿™ç§ä½¿ç”¨æ–¹å¼è·Ÿä¹‹å‰çš„ `let` ä¿æŒäº†ä¸€è‡´æ€§ï¼Œä½†æ˜¯ `let` ä¼šé‡æ–°ç»‘å®šï¼Œè€Œè¿™é‡Œä»…ä»…æ˜¯å¯¹ä¹‹å‰ç»‘å®šçš„å˜é‡è¿›è¡Œå†èµ‹å€¼ã€‚
>
>   ä½¿ç”¨ `+=` çš„èµ‹å€¼è¯­å¥è¿˜ä¸æ”¯æŒè§£æ„å¼èµ‹å€¼

### å˜é‡ä¸å¸¸é‡ä¹‹é—´çš„å·®å¼‚

-   å¸¸é‡ä¸å…è®¸ä½¿ç”¨ `mut`ã€‚**å¸¸é‡ä¸ä»…ä»…é»˜è®¤ä¸å¯å˜ï¼Œè€Œä¸”è‡ªå§‹è‡³ç»ˆä¸å¯å˜**ï¼Œå› ä¸ºå¸¸é‡åœ¨ç¼–è¯‘å®Œæˆåï¼Œå·²ç»ç¡®å®šå®ƒçš„å€¼ã€‚
-   å¸¸é‡ä½¿ç”¨ `const` å…³é”®å­—è€Œä¸æ˜¯ `let` å…³é”®å­—æ¥å£°æ˜ï¼Œå¹¶ä¸”å€¼çš„ç±»å‹**å¿…é¡»**æ ‡æ³¨ã€‚

### å˜é‡é®è”½(shadowing)

`Rust` å…è®¸å£°æ˜ç›¸åŒçš„å˜é‡åï¼Œåœ¨åé¢å£°æ˜çš„å˜é‡ä¼šé®è”½æ‰å‰é¢å£°æ˜çš„:

```rust
fn main() {
    let x = 5;
    // åœ¨mainå‡½æ•°çš„ä½œç”¨åŸŸå†…å¯¹ä¹‹å‰çš„xè¿›è¡Œé®è”½
    let x = x + 1;

    {
        // åœ¨å½“å‰çš„èŠ±æ‹¬å·ä½œç”¨åŸŸå†…ï¼Œå¯¹ä¹‹å‰çš„xè¿›è¡Œé®è”½
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```

è¿è¡Œï¼š

```bash
$ cargo run
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `./variables`
var shadowing
The value of x in the inner scope is: 12
The value of x is: 6
```

>   å¤šæ¬¡çš„`let`å£°æ˜äº†å¤šä¸ªåŒåå˜é‡ï¼Œä½¿ç”¨æ›´å¤šå†…å­˜
>
>   `mut`åªæ˜¯ä¿®æ”¹åŒä¸€å†…å­˜åœ°å€ä¸Šçš„å€¼ï¼Œä¸ä¼šå‘ç”Ÿå†…å­˜å¯¹è±¡çš„å†åˆ†é…ï¼Œæ€§èƒ½è¦æ›´å¥½

å˜é‡é®è”½çš„ä½œç”¨ï¼š
å¦‚æœä½ åœ¨æŸä¸ªä½œç”¨åŸŸå†…æ— éœ€å†ä½¿ç”¨ä¹‹å‰çš„å˜é‡ï¼ˆåœ¨è¢«é®è”½åï¼Œæ— æ³•å†è®¿é—®åˆ°ä¹‹å‰çš„åŒåå˜é‡ï¼‰ï¼Œå¯ä»¥é‡å¤çš„ä½¿ç”¨å˜é‡åå­—

## 2.2 åŸºæœ¬ç±»å‹

-   æ•°å€¼ç±»å‹: æœ‰ç¬¦å·æ•´æ•° (`i8`, `i16`, `i32`, `i64`, `isize`)ã€ æ— ç¬¦å·æ•´æ•° (`u8`, `u16`, `u32`, `u64`, `usize`) ã€æµ®ç‚¹æ•° (`f32`, `f64`)ã€ä»¥åŠæœ‰ç†æ•°ã€å¤æ•°
-   å­—ç¬¦ä¸²ï¼šå­—ç¬¦ä¸²å­—é¢é‡å’Œå­—ç¬¦ä¸²åˆ‡ç‰‡ `&str`
-   å¸ƒå°”ç±»å‹ï¼š `true`å’Œ`false`
-   å­—ç¬¦ç±»å‹: è¡¨ç¤ºå•ä¸ª Unicode å­—ç¬¦ï¼Œå­˜å‚¨ä¸º 4 ä¸ªå­—èŠ‚
-   å•å…ƒç±»å‹: å³ `()` ï¼Œå…¶å”¯ä¸€çš„å€¼ä¹Ÿæ˜¯ `()`

`Rust` æ˜¯ä¸€é—¨**é™æ€ç±»å‹**è¯­è¨€ï¼Œä¹Ÿå°±æ˜¯ç¼–è¯‘å™¨å¿…é¡»åœ¨ç¼–è¯‘æœŸçŸ¥é“æˆ‘ä»¬æ‰€æœ‰å˜é‡çš„ç±»å‹ï¼Œä½†è¿™ä¸æ„å‘³ç€ä½ éœ€è¦ä¸ºæ¯ä¸ªå˜é‡æŒ‡å®šç±»å‹ï¼Œå› ä¸º **Rust ç¼–è¯‘å™¨å¾ˆèªæ˜ï¼Œå®ƒå¯ä»¥æ ¹æ®å˜é‡çš„å€¼å’Œä¸Šä¸‹æ–‡ä¸­çš„ä½¿ç”¨æ–¹å¼æ¥è‡ªåŠ¨æ¨å¯¼å‡ºå˜é‡çš„ç±»å‹**

### 2.2.1 æ•°å€¼ç±»å‹

#### æ•´æ•°ç±»å‹

ç±»å‹å®šä¹‰çš„å½¢å¼ç»Ÿä¸€ä¸ºï¼š`æœ‰æ— ç¬¦å· + ç±»å‹å¤§å°(ä½æ•°)`

 eg: 

æœ‰ç¬¦å·ç±»å‹ï¼ši8ï¼Œi16ï¼Œi32ï¼ˆé»˜è®¤ç±»å‹ï¼‰ï¼Œi64ï¼Œi128ï¼Œisizeï¼ˆè§†æ¶æ„è€Œå®šï¼‰

æ— ç¬¦å·ç±»å‹ï¼šu8ï¼Œu16ï¼Œu32ï¼Œu64ï¼Œu128ï¼Œusizeï¼ˆè§†æ¶æ„è€Œå®šï¼‰

>æ•´å‹æº¢å‡ºï¼š
>
>debug æ¨¡å¼ä¸‹ä¼šæ£€æµ‹æ•°å€¼æº¢å‡ºï¼Œé€ æˆç¼–è¯‘å¤±è´¥ï¼ˆ`panic`ï¼‰
>
>--release æ¨¡å¼ä¸‹ä¸ä¼šæ£€æµ‹æº¢å‡ºï¼ŒRust ä¼šæŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºï¼ˆ*twoâ€™s complement wrapping*ï¼‰çš„è§„åˆ™å¤„ç†
>
>è¦æ˜¾å¼å¤„ç†å¯èƒ½çš„æº¢å‡ºï¼Œå¯ä»¥ä½¿ç”¨æ ‡å‡†åº“é’ˆå¯¹åŸå§‹æ•°å­—ç±»å‹æä¾›çš„è¿™äº›æ–¹æ³•ï¼š
>
>-   ä½¿ç”¨ `wrapping_*` æ–¹æ³•åœ¨æ‰€æœ‰æ¨¡å¼ä¸‹éƒ½æŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºè§„åˆ™å¤„ç†ï¼Œä¾‹å¦‚ `wrapping_add`
>-   å¦‚æœä½¿ç”¨ `checked_*` æ–¹æ³•æ—¶å‘ç”Ÿæº¢å‡ºï¼Œåˆ™è¿”å› `None` å€¼
>-   ä½¿ç”¨ `overflowing_*` æ–¹æ³•è¿”å›è¯¥å€¼å’Œä¸€ä¸ªæŒ‡ç¤ºæ˜¯å¦å­˜åœ¨æº¢å‡ºçš„å¸ƒå°”å€¼
>-   ä½¿ç”¨ `saturating_*` æ–¹æ³•ä½¿å€¼è¾¾åˆ°æœ€å°å€¼æˆ–æœ€å¤§å€¼

#### æµ®ç‚¹ç±»å‹

ä¸¤ç§åŸºæœ¬ç±»å‹ï¼š `f32` å’Œ `f64`ï¼ˆé»˜è®¤ï¼‰

#### NaN

å¯¹äºæ•°å­¦ä¸Šæœªå®šä¹‰çš„ç»“æœï¼Œä½¿ç”¨`NaN`æ¥å¤„ç†

å¯ä»¥ä½¿ç”¨ `is_nan()` ç­‰æ–¹æ³•ï¼Œå¯ä»¥ç”¨æ¥åˆ¤æ–­ä¸€ä¸ªæ•°å€¼æ˜¯å¦æ˜¯ `NaN` 

#### åºåˆ—ï¼ˆ`Range`ï¼‰

åºåˆ—åªå…è®¸ç”¨äºæ•°å­—æˆ–å­—ç¬¦ç±»å‹ï¼ŒåŸå› æ˜¯ï¼šå®ƒä»¬å¯ä»¥è¿ç»­ã€‚

eg:

```rust
for i in 1..=5 {
    println!("{}",i);
}
output: 
1
2
3
4
5
```

#### æ€»ç»“ï¼š

-   **Rust æ‹¥æœ‰ç›¸å½“å¤šçš„æ•°å€¼ç±»å‹**. ç†Ÿæ‚‰ç±»å‹å ç”¨çš„å­—èŠ‚æ•°ä¸èŒƒå›´
-   **ç±»å‹è½¬æ¢å¿…é¡»æ˜¯æ˜¾å¼çš„**
-   **Rust çš„æ•°å€¼ä¸Šå¯ä»¥ä½¿ç”¨æ–¹æ³•**. ä¾‹å¦‚ä½ å¯ä»¥ç”¨ä»¥ä¸‹æ–¹æ³•æ¥å°† `13.14` å–æ•´ï¼š`13.14_f32.round()`



### 2.2.2 å­—ç¬¦ã€å¸ƒå°”ã€å•å…ƒç±»å‹

#### å­—ç¬¦ç±»å‹

Rust çš„å­—ç¬¦ä¸ä»…ä»…æ˜¯ `ASCII`ï¼Œæ‰€æœ‰çš„ `Unicode` å€¼éƒ½å¯ä»¥ä½œä¸º Rust å­—ç¬¦ã€‚

```rust
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let g = 'å›½';
    let heart_eyed_cat = 'ğŸ˜»';
}
```

>   Rust çš„å­—ç¬¦åªèƒ½ç”¨ `''` æ¥è¡¨ç¤ºï¼Œ `""` æ˜¯ç•™ç»™å­—ç¬¦ä¸²çš„

#### å¸ƒå°”ï¼ˆboolï¼‰

å¸ƒå°”ç±»å‹æœ‰ä¸¤ä¸ªå¯èƒ½çš„å€¼ï¼š`true` å’Œ `false`ï¼Œå¤§å°ä¸º `1` ä¸ªå­—èŠ‚ï¼š

```rust
fn main() {
    let t = true;

    let f: bool = false; // ä½¿ç”¨ç±»å‹æ ‡æ³¨,æ˜¾å¼æŒ‡å®šfçš„ç±»å‹

    if f {
        println!("è¿™æ˜¯æ®µæ¯«æ— æ„ä¹‰çš„ä»£ç ");
    }
}
```

#### å•å…ƒç±»å‹

å•å…ƒç±»å‹å°±æ˜¯ `()`ï¼Œå”¯ä¸€çš„å€¼ä¹Ÿæ˜¯ `()` ã€‚

`main` å‡½æ•°å°±è¿”å›è¿™ä¸ªå•å…ƒç±»å‹ `()`

æ²¡æœ‰è¿”å›å€¼çš„å‡½æ•°åœ¨ Rust ä¸­æ˜¯æœ‰å•ç‹¬çš„å®šä¹‰çš„ï¼š`å‘æ•£å‡½æ•°`

### 2.2.3 è¯­å¥å’Œè¡¨è¾¾å¼

Rust çš„å‡½æ•°ä½“æ˜¯ç”±ä¸€ç³»åˆ—è¯­å¥ç»„æˆï¼Œæœ€åç”±ä¸€ä¸ªè¡¨è¾¾å¼æ¥è¿”å›å€¼ï¼Œä¾‹å¦‚ï¼š

```rust
fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // è¯­å¥
    let y = y + 5; // è¯­å¥
    x + y // è¡¨è¾¾å¼
}
```

è¡¨è¾¾å¼ä¼šåœ¨æ±‚å€¼åè¿”å›ä¸€ä¸ªå€¼

### 2.2.4 å‡½æ•°

![img](https://s2.loli.net/2022/03/10/nD7mvPi43Xpe9Of.png)

#### å‡½æ•°è¦ç‚¹

-   å‡½æ•°åå’Œå˜é‡åä½¿ç”¨ `snake case` ä¾‹å¦‚ `fn add_two() -> {}`
-   å‡½æ•°çš„ä½ç½®å¯ä»¥éšä¾¿æ”¾ï¼ŒRust ä¸å…³å¿ƒæˆ‘ä»¬åœ¨å“ªé‡Œå®šä¹‰äº†å‡½æ•°ï¼Œåªè¦æœ‰å®šä¹‰å³å¯
-   æ¯ä¸ªå‡½æ•°å‚æ•°éƒ½éœ€è¦æ ‡æ³¨ç±»å‹

#### å‡½æ•°è¿”å›

å‡½æ•°çš„è¿”å›å€¼å°±æ˜¯å‡½æ•°ä½“æœ€åä¸€æ¡è¡¨è¾¾å¼çš„è¿”å›å€¼ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ `return` æå‰è¿”å›ã€‚

#### `Rust` ä¸­ç‰¹æ®Šçš„è¿”å›ç±»å‹

##### æ— è¿”å›å€¼ `()`

å•å…ƒç±»å‹ `()`ï¼Œæ˜¯ä¸€ä¸ªé›¶é•¿åº¦çš„å…ƒç»„ã€‚å®ƒæ²¡å•¥ä½œç”¨ï¼Œä½†æ˜¯å¯ä»¥ç”¨æ¥è¡¨è¾¾ä¸€ä¸ªå‡½æ•°æ²¡æœ‰è¿”å›å€¼ï¼š

-   å‡½æ•°æ²¡æœ‰è¿”å›å€¼ï¼Œé‚£ä¹ˆè¿”å›ä¸€ä¸ª `()`
-   é€šè¿‡ `;` ç»“å°¾çš„è¡¨è¾¾å¼è¿”å›ä¸€ä¸ª `()`

##### æ°¸ä¸è¿”å›çš„å‡½æ•° `!`

ç”¨ `!` ä½œå‡½æ•°è¿”å›ç±»å‹çš„æ—¶å€™ï¼Œè¡¨ç¤ºè¯¥å‡½æ•°æ°¸ä¸è¿”å›

eg:

```rust
fn forever() -> ! {
  loop {
    //...
  };
}
```

## 2.3 æ‰€æœ‰æƒä¸å€Ÿç”¨â­ï¸

### 2.3.1 æ‰€æœ‰æƒ

å¦‚ä½•ç®¡ç†ç³»ç»Ÿå†…å­˜ï¼š

-   **åƒåœ¾å›æ”¶æœºåˆ¶(GC)**ï¼Œåœ¨ç¨‹åºè¿è¡Œæ—¶ä¸æ–­å¯»æ‰¾ä¸å†ä½¿ç”¨çš„å†…å­˜ï¼Œå…¸å‹ä»£è¡¨ï¼šJavaã€Go
-   **æ‰‹åŠ¨ç®¡ç†å†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾**, åœ¨ç¨‹åºä¸­ï¼Œé€šè¿‡å‡½æ•°è°ƒç”¨çš„æ–¹å¼æ¥ç”³è¯·å’Œé‡Šæ”¾å†…å­˜ï¼Œå…¸å‹ä»£è¡¨ï¼šC++
-   **é€šè¿‡æ‰€æœ‰æƒæ¥ç®¡ç†å†…å­˜**ï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶ä¼šæ ¹æ®ä¸€ç³»åˆ—è§„åˆ™è¿›è¡Œæ£€æŸ¥

é€šè¿‡æ‰€æœ‰æƒæ¥ç®¡ç†å†…å­˜æ£€æŸ¥åªå‘ç”Ÿåœ¨ç¼–è¯‘æœŸï¼Œè¿è¡ŒæœŸä¸ä¼šæœ‰æ€§èƒ½æŸè€—

#### æ‰€æœ‰æƒåŸåˆ™

1.  Rust ä¸­æ¯ä¸€ä¸ªå€¼éƒ½ `æœ‰ä¸”åªæœ‰` ä¸€ä¸ªæ‰€æœ‰è€…(å˜é‡)
2.  å½“æ‰€æœ‰è€…(å˜é‡)ç¦»å¼€ä½œç”¨åŸŸèŒƒå›´æ—¶ï¼Œè¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒ(drop)

å¯¹äºç®€å•ç±»å‹çš„å˜é‡ï¼šæ ˆä¸Šç›´æ¥å°†æ•°æ®æ‹·è´ï¼Œèµ‹å€¼ç»™æ–°å˜é‡

å¯¹äºå¤æ‚ç±»å‹çš„å˜é‡ï¼šå¤æ‚å¯¹è±¡çš„æŒ‡é’ˆèµ‹å€¼ç»™æ–°çš„å˜é‡ä¼šå¯¼è‡´æ—§çš„æŒ‡é’ˆå˜é‡å¤±æ•ˆ => å¯¹æ­¤å¤æ‚å¯¹è±¡çš„æ‰€æœ‰æƒè½¬ç§»

>   ä»¥ `String` ä¸ºä¾‹æ€è€ƒï¼š
>
>   `String` ç±»å‹æŒ‡å‘äº†ä¸€ä¸ªå †ä¸Šçš„ç©ºé—´ï¼Œå­˜å‚¨ç€å®ƒçš„çœŸå®æ•°æ®, å¯¹äºä»£ç ä¸­çš„ `let s2 = s1` åˆ†æˆä¸¤ç§æƒ…å†µè®¨è®ºï¼š
>
>   1.  æ‹·è´ `String` å’Œå­˜å‚¨åœ¨å †ä¸Šçš„å­—èŠ‚æ•°ç»„ å¦‚æœè¯¥è¯­å¥æ˜¯æ‹·è´æ‰€æœ‰æ•°æ®(æ·±æ‹·è´)ï¼Œé‚£ä¹ˆæ— è®ºæ˜¯ `String` æœ¬èº«è¿˜æ˜¯åº•å±‚çš„å †ä¸Šæ•°æ®ï¼Œéƒ½ä¼šè¢«å…¨éƒ¨æ‹·è´ï¼Œè¿™å¯¹äºæ€§èƒ½è€Œè¨€ä¼šé€ æˆéå¸¸å¤§çš„å½±å“
>   2.  åªæ‹·è´ `String` æœ¬èº« è¿™æ ·çš„æ‹·è´éå¸¸å¿«ï¼Œå› ä¸ºåœ¨ 64 ä½æœºå™¨ä¸Šå°±æ‹·è´äº† `8å­—èŠ‚çš„æŒ‡é’ˆ`ã€`8å­—èŠ‚çš„é•¿åº¦`ã€`8å­—èŠ‚çš„å®¹é‡`ï¼Œæ€»è®¡ 24 å­—èŠ‚ï¼Œä½†æ˜¯å¸¦æ¥äº†æ–°çš„é—®é¢˜ï¼Œæ ¹æ®æ‰€æœ‰æƒè§„åˆ™ï¼Œå…¶ä¸­ä¸€æ¡ï¼š**ä¸€ä¸ªå€¼åªå…è®¸æœ‰ä¸€ä¸ªæ‰€æœ‰è€…**ï¼Œè€Œç°åœ¨è¿™ä¸ªå€¼ï¼ˆå †ä¸Šçš„çœŸå®å­—ç¬¦ä¸²æ•°æ®ï¼‰æœ‰äº†ä¸¤ä¸ªæ‰€æœ‰è€…ï¼š`s1` å’Œ `s2`ã€‚å‡å®šä¸€ä¸ªå€¼å¯ä»¥æ‹¥æœ‰ä¸¤ä¸ªæ‰€æœ‰è€…ï¼Œå°±ä¼šå¯¼è‡´ **äºŒæ¬¡é‡Šæ”¾ï¼ˆdouble freeï¼‰** çš„é”™è¯¯ã€‚

eg:

```rust
#![allow(unused)]
fn main() {
  let s1 = String::from("hello");
  let s2 = s1;
	println!("{}, world!", s1);
}
output:
error[E0382]: use of moved value: `s1`
 --> src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
```

â—ï¸æ­¤æ—¶å†æ€è€ƒ **å˜é‡ç»‘å®š** ä¸ **å˜é‡èµ‹å€¼**è¯­ä¹‰ä¸Šçš„åŒºåˆ«

#### å…‹éš†ï¼ˆæ·±æ‹·è´ï¼‰

**Rust æ°¸è¿œä¹Ÿä¸ä¼šè‡ªåŠ¨åˆ›å»ºæ•°æ®çš„ â€œæ·±æ‹·è´â€**  => ä»»ä½•**è‡ªåŠ¨**çš„å¤åˆ¶éƒ½ä¸æ˜¯æ·±æ‹·è´

 ä½¿ç”¨ `clone()` è¿›è¡Œæ·±æ‹·è´

eg:

```rust
#![allow(unused)]
fn main() {
  let s1 = String::from("hello");
  let s2 = s1.clone();

  println!("s1 = {}, s2 = {}", s1, s2);
}
output:
s1 = hello, s2 = hello
```

#### æ‹·è´ï¼ˆæµ…æ‹·è´ï¼‰

æµ…æ‹·è´åªå‘ç”Ÿåœ¨æ ˆ

Rust æœ‰ä¸€ä¸ªå«åš `Copy` çš„ç‰¹å¾ï¼Œå¯ä»¥ç”¨åœ¨ç±»ä¼¼æ•´å‹è¿™æ ·åœ¨æ ˆä¸­å­˜å‚¨çš„ç±»å‹ã€‚å¦‚æœä¸€ä¸ªç±»å‹æ‹¥æœ‰ `Copy` ç‰¹å¾ï¼Œä¸€ä¸ªæ—§çš„å˜é‡åœ¨è¢«èµ‹å€¼ç»™å…¶ä»–å˜é‡åä»ç„¶å¯ç”¨ã€‚

 **ä»»ä½•åŸºæœ¬ç±»å‹çš„ç»„åˆå¯ä»¥ `Copy` ï¼Œä¸éœ€è¦åˆ†é…å†…å­˜æˆ–æŸç§å½¢å¼èµ„æºçš„ç±»å‹æ˜¯å¯ä»¥ `Copy` çš„**ã€‚å¦‚ä¸‹æ˜¯ä¸€äº› `Copy` çš„ç±»å‹ï¼š

-   æ‰€æœ‰æ•´æ•°ç±»å‹ï¼Œæ¯”å¦‚ `u32`ã€‚
-   å¸ƒå°”ç±»å‹ï¼Œ`bool`ï¼Œå®ƒçš„å€¼æ˜¯ `true` å’Œ `false`ã€‚
-   æ‰€æœ‰æµ®ç‚¹æ•°ç±»å‹ï¼Œæ¯”å¦‚ `f64`ã€‚
-   å­—ç¬¦ç±»å‹ï¼Œ`char`ã€‚
-   å…ƒç»„ï¼Œå½“ä¸”ä»…å½“å…¶åŒ…å«çš„ç±»å‹ä¹Ÿéƒ½æ˜¯ `Copy` çš„æ—¶å€™ã€‚æ¯”å¦‚ï¼Œ`(i32, i32)` æ˜¯ `Copy` çš„ï¼Œä½† `(i32, String)` å°±ä¸æ˜¯ã€‚
-   å¼•ç”¨ç±»å‹

#### å‡½æ•°ä¼ å€¼ä¸è¿”å›

å°†å€¼ä¼ é€’ç»™å‡½æ•°ï¼Œä¸€æ ·ä¼šå‘ç”Ÿ `ç§»åŠ¨` æˆ–è€… `å¤åˆ¶`ï¼Œå°±è·Ÿ `let` è¯­å¥ä¸€æ ·ã€‚

```rust
fn main() {
    let s = String::from("hello");  // s è¿›å…¥ä½œç”¨åŸŸ

    takes_ownership(s);             // s çš„å€¼ç§»åŠ¨åˆ°å‡½æ•°é‡Œ ...
                                    // ... æ‰€ä»¥åˆ°è¿™é‡Œä¸å†æœ‰æ•ˆ

    let x = 5;                      // x è¿›å…¥ä½œç”¨åŸŸ

    makes_copy(x);                  // x åº”è¯¥ç§»åŠ¨å‡½æ•°é‡Œï¼Œ
                                    // ä½† i32 æ˜¯ Copy çš„ï¼Œæ‰€ä»¥åœ¨åé¢å¯ç»§ç»­ä½¿ç”¨ x

} // è¿™é‡Œ, x å…ˆç§»å‡ºäº†ä½œç”¨åŸŸï¼Œç„¶åæ˜¯ sã€‚ä½†å› ä¸º s çš„å€¼å·²è¢«ç§»èµ°ï¼Œ
  // æ‰€ä»¥ä¸ä¼šæœ‰ç‰¹æ®Šæ“ä½œ

fn takes_ownership(some_string: String) { // some_string è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_string);
} // è¿™é‡Œï¼Œsome_string ç§»å‡ºä½œç”¨åŸŸå¹¶è°ƒç”¨ `drop` æ–¹æ³•ã€‚å ç”¨çš„å†…å­˜è¢«é‡Šæ”¾

fn makes_copy(some_integer: i32) { // some_integer è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_integer);
} // è¿™é‡Œï¼Œsome_integer ç§»å‡ºä½œç”¨åŸŸã€‚ä¸ä¼šæœ‰ç‰¹æ®Šæ“ä½œ
```

åŒæ ·çš„ï¼Œå‡½æ•°è¿”å›å€¼ä¹Ÿæœ‰æ‰€æœ‰æƒï¼Œä¾‹å¦‚:

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership å°†è¿”å›å€¼
                                        // ç§»ç»™ s1

    let s2 = String::from("hello");     // s2 è¿›å…¥ä½œç”¨åŸŸ

    let s3 = takes_and_gives_back(s2);  // s2 è¢«ç§»åŠ¨åˆ°
                                        // takes_and_gives_back ä¸­,
                                        // å®ƒä¹Ÿå°†è¿”å›å€¼ç§»ç»™ s3
} // è¿™é‡Œ, s3 ç§»å‡ºä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒã€‚s2 ä¹Ÿç§»å‡ºä½œç”¨åŸŸï¼Œä½†å·²è¢«ç§»èµ°ï¼Œ
  // æ‰€ä»¥ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿã€‚s1 ç§»å‡ºä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ

fn gives_ownership() -> String {             // gives_ownership å°†è¿”å›å€¼ç§»åŠ¨ç»™
                                             // è°ƒç”¨å®ƒçš„å‡½æ•°

    let some_string = String::from("hello"); // some_string è¿›å…¥ä½œç”¨åŸŸ.

    some_string                              // è¿”å› some_string å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
}

// takes_and_gives_back å°†ä¼ å…¥å­—ç¬¦ä¸²å¹¶è¿”å›è¯¥å€¼
fn takes_and_gives_back(a_string: String) -> String { // a_string è¿›å…¥ä½œç”¨åŸŸ

    a_string  // è¿”å› a_string å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
}
```

### 2.3.2 å¼•ç”¨ä¸å€Ÿç”¨

å¦‚æœä»…ä»…ä½¿ç”¨å˜é‡çš„æŒ‡é’ˆæˆ–è€…å¼•ç”¨ï¼Œè€Œéè·å¾—æ‰€æœ‰æƒï¼Œå¯ä»¥é€šè¿‡ `å€Ÿç”¨(Borrowing)` ï¼Œ**è·å–å˜é‡çš„å¼•ç”¨ï¼Œç§°ä¹‹ä¸ºå€Ÿç”¨(borrowing)**ã€‚

#### å¼•ç”¨ä¸è§£å¼•ç”¨

```rust
fn main() {
    let x = 5;
    let y = &x; // è·å–æŒ‡å‘xçš„å¼•ç”¨

    assert_eq!(5, x);
    assert_eq!(5, *y); // é€šè¿‡ `*` è§£å¼•ç”¨ï¼Œå¾—åˆ°yæ‰€æŒ‡å‘çš„æ•°æ® 
}
```

#### ä¸å¯å˜å¼•ç”¨

ä¸‹é¢çš„ä»£ç ï¼Œæˆ‘ä»¬ç”¨ `s1` çš„å¼•ç”¨ä½œä¸ºå‚æ•°ä¼ é€’ç»™ `calculate_length` å‡½æ•°ï¼Œè€Œä¸æ˜¯æŠŠ `s1` çš„æ‰€æœ‰æƒè½¬ç§»ç»™è¯¥å‡½æ•°ï¼š

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
output:
The length of 'hello' is 5.
```

å˜åŒ–è¿‡ç¨‹ï¼š

![&String s pointing at String s1](https://s2.loli.net/2022/03/13/bnqGQHhCDvy2pF7.jpg)

#### å¯å˜å¼•ç”¨

é€šè¿‡ `mut` å…³é”®å­—ï¼Œå¯ä»¥æ“ä½œå¼•ç”¨æ‰€æŒ‡å‘çš„æ•°æ®

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
    println!("s is :{}", s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
output:
s is :hello, world
```

å®ƒæœ‰ä¸€ä¸ªå¾ˆå¤§çš„é™åˆ¶ï¼š **åŒä¸€ä½œç”¨åŸŸï¼Œç‰¹å®šæ•°æ®åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨**ï¼š

```rust
#![allow(unused)]
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
}
output:
error[E0499]: cannot borrow `s` as mutable more than once at a time
  --> src/main.rs:10:14
   |
9  |     let r1 = &mut s;
   |              ------ first mutable borrow occurs here
10 |     let r2 = &mut s;
   |              ^^^^^^ second mutable borrow occurs here
11 | 
12 |     println!("{}, {}", r1, r2);
   |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `hello_world` due to previous error
```

##### å¯å˜å¼•ç”¨ä¸ä¸å¯å˜å¼•ç”¨ä¸èƒ½åŒæ—¶å­˜åœ¨

```rust
#![allow(unused)]
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // æ²¡é—®é¢˜
    let r2 = &s; // æ²¡é—®é¢˜
    let r3 = &mut s; // å¤§é—®é¢˜

    println!("{}, {}, and {}", r1, r2, r3);
}
```

#### æ‚¬å‚å¼•ç”¨(Dangling References)

æ‚¬å‚å¼•ç”¨ä¹Ÿå«åšæ‚¬å‚æŒ‡é’ˆï¼Œæ„æ€ä¸ºæŒ‡é’ˆæŒ‡å‘æŸä¸ªå€¼åï¼Œè¿™ä¸ªå€¼è¢«é‡Šæ”¾æ‰äº†ï¼Œè€ŒæŒ‡é’ˆä»ç„¶å­˜åœ¨ï¼Œå…¶æŒ‡å‘çš„å†…å­˜å¯èƒ½ä¸å­˜åœ¨ä»»ä½•å€¼æˆ–å·²è¢«å…¶å®ƒå˜é‡é‡æ–°ä½¿ç”¨ã€‚

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
output:
error[E0106]: missing lifetime specifier
  --> src/main.rs:11:16
   |
11 | fn dangle() -> &String {
   |                ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
   |
11 | fn dangle() -> &'static String {
   |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `hello_world` due to previous error
```

#### å€Ÿç”¨è§„åˆ™æ€»ç»“

æ€»çš„æ¥è¯´ï¼Œå€Ÿç”¨è§„åˆ™å¦‚ä¸‹ï¼š

-   åŒä¸€æ—¶åˆ»ï¼Œä½ åªèƒ½æ‹¥æœ‰è¦ä¹ˆä¸€ä¸ªå¯å˜å¼•ç”¨, è¦ä¹ˆä»»æ„å¤šä¸ªä¸å¯å˜å¼•ç”¨
-   å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„

## 2.4 å¤åˆç±»å‹

å¤åˆç±»å‹æ˜¯ç”±å…¶å®ƒç±»å‹ç»„åˆè€Œæˆçš„ï¼Œæœ€å…¸å‹çš„å°±æ˜¯ç»“æ„ä½“ `struct` å’Œæšä¸¾ `enum`ã€‚

### 2.4.1 å­—ç¬¦ä¸²å’Œåˆ‡ç‰‡

Will it be success?

```rust
fn main() {
    let my_name = "Akira";
    greet(my_name);
}

fn greet(name: String) {
    println!("Hello, {}!", name);
}
output:
error[E0308]: mismatched types
 --> src/main.rs:3:11
  |
3 |     greet(my_name);
  |           ^^^^^^^- help: try using a conversion method: `.to_string()`
  |           |
  |           expected struct `String`, found `&str`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `string` due to previous error
```

#### åˆ‡ç‰‡ï¼ˆsliceï¼‰

åˆ‡ç‰‡å…è®¸ä½ å¼•ç”¨é›†åˆä¸­éƒ¨åˆ†è¿ç»­çš„å…ƒç´ åºåˆ—ï¼Œè€Œä¸æ˜¯å¼•ç”¨æ•´ä¸ªé›†åˆã€‚

åˆ›å»ºåˆ‡ç‰‡çš„è¯­æ³•ï¼Œä½¿ç”¨æ–¹æ‹¬å·åŒ…æ‹¬çš„ä¸€ä¸ªåºåˆ—: **[å¼€å§‹ç´¢å¼•..ç»ˆæ­¢ç´¢å¼•]**ï¼Œæ˜¯è¿™æ˜¯ä¸€ä¸ª `å·¦é—­å³å¼€åŒºé—´`ã€‚

eg:

```rust
#![allow(unused_variables)]
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
    println!("{} {}", hello, world);
}
output:
hello world
```

åˆ‡ç‰‡è§£æï¼š

<img src="https://s2.loli.net/2022/03/14/nhHQXYtfuUKOdsA.jpg" alt="img" style="zoom:20%;" />

```rust
let s = String::from("hello");

// è·å–å‰ä¸¤ä¸ªå­—èŠ‚æ•°æ®
let slice = &s[0..2]; 
let slice = &s[..2];

// è·å–å®Œæ•´å­—èŠ‚æ•°æ®
let slice = &s[0..len];
let slice = &s[..];
```

>   å¯¹å­—ç¬¦ä¸²è¿›è¡Œåˆ‡ç‰‡ï¼Œéœ€è¦æ³¨æ„å­—ç¬¦ä¸²çš„ç¼–ç ï¼Œå¦åˆ™å¯¼è‡´ç¨‹åºä¼šç›´æ¥å´©æºƒé€€å‡º
>   eg:
>
>   ```rust
>   #![allow(unused)]
>   fn main() {
>       let s = "ä¸­å›½äºº";
>       let a = &s[0..2];
>       println!("{}", a);
>   }
>   output:
>   thread 'main' panicked at 'byte index 2 is not a char boundary; it is inside 'ä¸­' (bytes 0..3) of `ä¸­å›½äºº`'
>   ```

#### å­—ç¬¦ä¸²å­—é¢é‡æ˜¯åˆ‡ç‰‡

å­—ç¬¦ä¸²å˜é‡çš„ç±»å‹æ˜¯ `&str`

eg:`let s: &str = "Hello, world!";`

#### ä»€ä¹ˆæ˜¯å­—ç¬¦ä¸²ï¼Ÿ

**`Rust` ä¸­å­—ç¬¦ä¸² `UTF-8` ç¼–ç ï¼Œä¹Ÿå°±æ˜¯å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦æ‰€å çš„å­—èŠ‚æ•°æ˜¯å˜åŒ–çš„(1 - 4)**ã€‚

`String` æ˜¯ä¸€ä¸ªå¯å¢é•¿ã€å¯æ”¹å˜ä¸”å…·æœ‰æ‰€æœ‰æƒçš„ UTF-8 ç¼–ç å­—ç¬¦ä¸²

**å½“ Rust ç”¨æˆ·æåˆ°å­—ç¬¦ä¸²æ—¶ï¼Œå¾€å¾€æŒ‡çš„å°±æ˜¯ `String` ç±»å‹å’Œ `&str` å­—ç¬¦ä¸²åˆ‡ç‰‡ç±»å‹ï¼Œè¿™ä¸¤ä¸ªç±»å‹éƒ½æ˜¯ UTF-8 ç¼–ç **ã€‚

##### æ“ä½œå­—ç¬¦ä¸²

```rust
fn main() {
    // åˆ›å»ºä¸€ä¸ªç©ºString
    let mut s = String::new();
    // å°†&strç±»å‹çš„"hello,world"æ·»åŠ åˆ°sä¸­
    s.push_str("hello,world");
    // å°†å­—ç¬¦'!'æ¨å…¥sä¸­
    s.push('!');
    // æœ€åsçš„å†…å®¹æ˜¯"hello,world!"
    assert_eq!(s,"hello,world!");

    // ä»ç°æœ‰çš„&stråˆ‡ç‰‡åˆ›å»ºStringç±»å‹
    let mut s = "hello,world".to_string();
    // å°†å­—ç¬¦'!'æ¨å…¥sä¸­
    s.push('!');
    // æœ€åsçš„å†…å®¹æ˜¯"hello,world!"
    assert_eq!(s,"hello,world!");

    // ä»ç°æœ‰çš„&stråˆ‡ç‰‡åˆ›å»ºStringç±»å‹
    // Stringä¸&stréƒ½æ˜¯UTF-8ç¼–ç ï¼Œå› æ­¤æ”¯æŒä¸­æ–‡
    let mut s = String::from("ä½ å¥½,ä¸–ç•Œ");
    // å°†å­—ç¬¦'!'æ¨å…¥sä¸­
    s.push('!');
    // æœ€åsçš„å†…å®¹æ˜¯"ä½ å¥½,ä¸–ç•Œ!"
    assert_eq!(s,"ä½ å¥½,ä¸–ç•Œ!");

    let s1 = String::from("hello,");
    let s2 = String::from("world!");
    // åœ¨ä¸‹å¥ä¸­ï¼Œs1çš„æ‰€æœ‰æƒè¢«è½¬ç§»èµ°äº†ï¼Œå› æ­¤åé¢ä¸èƒ½å†ä½¿ç”¨s1
    let s3 = s1 + &s2;
    assert_eq!(s3,"hello,world!");
    // ä¸‹é¢çš„è¯­å¥å¦‚æœå»æ‰æ³¨é‡Šï¼Œå°±ä¼šæŠ¥é”™
    // println!("{}",s1);
}
```

##### String ä¸ &str çš„è½¬æ¢

1.   `&str` ç±»å‹ç”Ÿæˆ `String` ç±»å‹

     -   `String::from("hello,world")`
     -   `"hello,world".to_string()`

2.   `String` ç±»å‹è½¬ä¸º `&str` ç±»å‹

     ```rust
     fn main() {
         let s = String::from("hello,world!");
         say_hello(&s);
         say_hello(&s[..]);
         say_hello(s.as_str());
     }
     
     fn say_hello(s: &str) {
         println!("{}",s);
     }
     ```

##### å­—ç¬¦ä¸²ç´¢å¼•

å­—ç¬¦ä¸²çš„åº•å±‚æ˜¯[ `u8` ]ï¼Œä¸€ä¸ªå­—èŠ‚æ•°ç»„ã€‚å¯¹äºä¸åŒç±»å‹å­—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œç´¢å¼•ä¸‹çš„å­—ç¬¦å¯èƒ½æ— æ„ä¹‰ã€‚

```rust
#![allow(unused)]
fn main() {
    let s1 = String::from("hello");
    let h = s1[0];
}
output:
error[E0277]: the type `String` cannot be indexed by `{integer}`
  --> src/main.rs:63:13
   |
63 |     let h = s1[0];
   |             ^^^^^ `String` cannot be indexed by `{integer}`
   |
   = help: the trait `Index<{integer}>` is not implemented for `String`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `string` due to previous error
```

>   å¦ä¸€ä¸ªåŸå› å¯¼è‡´äº† Rust ä¸å…è®¸å»ç´¢å¼•å­—ç¬¦ä¸²ï¼šå› ä¸ºç´¢å¼•æ“ä½œï¼Œæˆ‘ä»¬æ€»æ˜¯æœŸæœ›å®ƒçš„æ€§èƒ½è¡¨ç°æ˜¯ O(1)ï¼Œç„¶è€Œå¯¹äº `String` ç±»å‹æ¥è¯´ï¼Œæ— æ³•ä¿è¯è¿™ä¸€ç‚¹ï¼Œå› ä¸º Rust å¯èƒ½éœ€è¦ä» 0 å¼€å§‹å»éå†å­—ç¬¦ä¸²æ¥å®šä½åˆæ³•çš„å­—ç¬¦ã€‚

##### æ“ä½œ `UTF8` å­—ç¬¦ä¸²

ä»¥ Unicode å­—ç¬¦çš„æ–¹å¼éå†å­—ç¬¦ä¸²ï¼Œæœ€å¥½çš„åŠæ³•æ˜¯ä½¿ç”¨ `chars` æ–¹æ³•ï¼š

```rust
#![allow(unused)]
fn main() {
    for c in "ä¸­å›½äºº".chars() {
        println!("{}", c);
    }
}
output:
ä¸­
å›½
äºº
```

è¿”å›å­—ç¬¦ä¸²çš„åº•å±‚å­—èŠ‚æ•°ç»„è¡¨ç°å½¢å¼ï¼š

```rust
#![allow(unused)]
fn main() {
    for b in "ä¸­å›½äºº".bytes() {
        println!("{}", b);
    }
}
output:
228
184
173
229
155
189
228
186
186
```

##### å­—ç¬¦ä¸²æ·±åº¦å‰–æ

ä¸ºå•¥ `String` å¯å˜ï¼Œè€Œå­—ç¬¦ä¸²å­—é¢å€¼ `str` å´ä¸å¯ä»¥ï¼Ÿ

å­—ç¬¦ä¸²å­—é¢å€¼åœ¨ç¼–è¯‘æ—¶ç›´æ¥ç¡¬ç¼–ç è¿›å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼Œå¿«é€Ÿä¸”é«˜æ•ˆã€‚

`String` ç±»å‹çš„å­˜åœ¨ä¸ºäº†æ”¯æŒä¸€ä¸ªå¯å˜çš„æ–‡æœ¬ä¸²ï¼Œéœ€è¦åœ¨å †ä¸Šåˆ†é…æœªçŸ¥å¤§å°çš„å†…å­˜æ¥å­˜æ”¾ã€‚

åœ¨ç¨‹åºè¿è¡Œæ—¶ï¼š

-   é¦–å…ˆå‘æ“ä½œç³»ç»Ÿè¯·æ±‚å†…å­˜æ¥å­˜æ”¾ `String` å¯¹è±¡
-   åœ¨ä½¿ç”¨å®Œæˆåï¼Œå°†å†…å­˜é‡Šæ”¾ï¼Œå½’è¿˜ç»™æ“ä½œç³»ç»Ÿ

### 2.4.2 å…ƒç»„

å…ƒç»„æ˜¯ç”±å¤šç§ç±»å‹ç»„åˆåˆ°ä¸€èµ·å½¢æˆçš„ï¼Œé•¿åº¦å›ºå®šï¼Œé¡ºåºå›ºå®šã€‚

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
```

ä½¿ç”¨æ¨¡å¼åŒ¹é…æˆ–è€… `.` æ“ä½œç¬¦æ¥è·å–å…ƒç»„ä¸­çš„å€¼

```rust
let tup = (500, 6.4, 1);
let (x, y, z) = tup;

-----------------------
let x: (i32, f64, u8) = (500, 6.4, 1);

let five_hundred = x.0;

let six_point_four = x.1;

let one = x.2;
```

### 2.4.3 ç»“æ„ä½“

ä¸€ä¸ªç»“æ„ä½“æœ‰å‡ éƒ¨åˆ†ç»„æˆï¼š

-   é€šè¿‡å…³é”®å­— `struct` å®šä¹‰
-   ä¸€ä¸ªæ¸…æ™°æ˜ç¡®çš„ç»“æ„ä½“ `åç§°`
-   å‡ ä¸ªæœ‰åå­—çš„ç»“æ„ä½“ `å­—æ®µ`

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

#### åˆ›å»ºç»“æ„ä½“å®ä¾‹

```rust
let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
};
```

â—ï¸æ³¨æ„

1.  åˆå§‹åŒ–å®ä¾‹æ—¶ï¼Œ**æ¯ä¸ªå­—æ®µ**éƒ½éœ€è¦è¿›è¡Œåˆå§‹åŒ–
2.  åˆå§‹åŒ–æ—¶çš„å­—æ®µé¡ºåº**ä¸éœ€è¦**å’Œç»“æ„ä½“å®šä¹‰æ—¶çš„é¡ºåºä¸€è‡´

é€šè¿‡ `.` æ“ä½œç¬¦å³å¯æ“ä½œç»“æ„ä½“å®ä¾‹å†…éƒ¨çš„å­—æ®µå€¼

```rust
let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

user1.email = String::from("anotheremail@example.com");
```

â—ï¸æ³¨æ„

åªæœ‰ç»“æ„ä½“å®ä¾‹å£°æ˜ä¸ºå¯å˜çš„ï¼Œæ‰èƒ½ä¿®æ”¹å…¶ä¸­çš„å­—æ®µï¼Œä¸æ”¯æŒç»“æ„ä½“å†…éƒ¨å­—æ®µå¯å˜

#### ç®€åŒ–ç»“æ„ä½“åˆ›å»º

```rust
eg1:
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
eg2:
// å½“å‡½æ•°å‚æ•°å’Œç»“æ„ä½“å­—æ®µåŒåæ—¶ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ç¼©ç•¥
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
```

#### ç»“æ„ä½“æ›´æ–°è¯­æ³•

æ ¹æ®å·²æœ‰çš„ç»“æ„ä½“å®ä¾‹ï¼Œåˆ›å»ºæ–°çš„ç»“æ„ä½“å®ä¾‹:

```rust
Method1ï¼š
let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };

Method2ï¼š
let user2 = User {
        email: String::from("another@example.com"),
  			// .. è¯­æ³•è¡¨æ˜å‡¡æ˜¯æˆ‘ä»¬æ²¡æœ‰æ˜¾ç¤ºå£°æ˜çš„å­—æ®µå…¨éƒ¨ä» user1 ä¸­è‡ªåŠ¨è·å–
  			// ..user1 å¿…é¡»åœ¨ç»“æ„ä½“çš„å°¾éƒ¨ä½¿ç”¨
        ..user1
    };
```

>   ç»“æ„ä½“æ›´æ–°è¯­æ³•è·Ÿèµ‹å€¼è¯­å¥ `=` éå¸¸ç›¸åƒï¼Œå› æ­¤åœ¨ä¸Šé¢ä»£ç ä¸­ï¼Œ`user1` çš„éƒ¨åˆ†å­—æ®µæ‰€æœ‰æƒè¢«è½¬ç§»åˆ° `user2` ä¸­ï¼š`username` å­—æ®µå‘ç”Ÿäº†æ‰€æœ‰æƒè½¬ç§»ï¼Œä½œä¸ºç»“æœï¼Œ`user1` æ— æ³•å†è¢«ä½¿ç”¨ã€‚ä½†æ˜¯å¹¶ä¸ä»£è¡¨ `user1` å†…éƒ¨çš„å…¶å®ƒå­—æ®µä¸èƒ½è¢«ç»§ç»­ä½¿ç”¨ï¼Œä¾‹å¦‚ï¼š
>
>   ```rust
>   fn main() {
>       let user1 = User {
>           email: String::from("someone@example.com"),
>           username: String::from("someusername123"),
>           active: true,
>           sign_in_count: 1,
>       };
>       let user2 = User {
>           active: user1.active,
>           username: user1.username,
>           email: String::from("another@example.com"),
>           sign_in_count: user1.sign_in_count,
>       };
>       println!("{}", user1.active);
>       // ä¸‹é¢è¿™è¡Œä¼šæŠ¥é”™
>       println!("{:?}", user1);
>   }
>   output:
>   error[E0382]: borrow of partially moved value: `user1`
>     --> src/main.rs:68:22
>      |
>   62 |         username: user1.username,
>      |                   -------------- value partially moved here
>   ...
>   68 |     println!("{:?}", user1);
>      |                      ^^^^^ value borrowed here after partial move
>      |
>      = note: partial move occurs because `user1.username` has type `String`, which does not implement the `Copy` trait
>      = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)
>   
>   For more information about this error, try `rustc --explain E0382`.
>   warning: `struct-demo` (bin "struct-demo") generated 1 warning
>   error: could not compile `struct-demo` due to previous error; 1 warning emitted
>   ```

#### ç»“æ„ä½“çš„å†…å­˜æ’åˆ—

code exampleï¼š

```rust
#[derive(Debug)]
 struct File {
   name: String,
   data: Vec<u8>,
 }

 fn main() {
   let f1 = File {
     name: String::from("f1.txt"),
     data: Vec::new(),
   };

   let f1_name = &f1.name;
   let f1_length = &f1.data.len();

   println!("{:?}", f1);
   println!("{} is {} bytes long", f1_name, f1_length);
 }
```

å†…å­˜æ’åˆ—å¦‚å›¾ï¼š

![image-20220315133114763](https://s2.loli.net/2022/03/15/coq7TkyLaYuJVfW.png)

#### å…ƒç»„ç»“æ„ä½“

ç»“æ„ä½“çš„å­—æ®µå¯ä»¥æ²¡æœ‰åç§°ï¼š

```rust
#[allow(unused)]
fn main() {
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```

#### å•å…ƒç»“æ„ä½“

å¦‚æœä½ å®šä¹‰ä¸€ä¸ªç±»å‹ï¼Œä½†æ˜¯ä¸å…³å¿ƒè¯¥ç±»å‹çš„å†…å®¹, åªå…³å¿ƒå®ƒçš„è¡Œä¸ºæ—¶ï¼Œå°±å¯ä»¥ä½¿ç”¨ `å•å…ƒç»“æ„ä½“`ï¼š

```rust
#[allow(unused)]
fn main() {
    struct AlwaysEqual;

    let subject = AlwaysEqual;

    // æˆ‘ä»¬ä¸å…³å¿ƒ AlwaysEqual çš„å­—æ®µæ•°æ®ï¼Œåªå…³å¿ƒå®ƒçš„è¡Œä¸ºï¼Œå› æ­¤å°†å®ƒå£°æ˜ä¸ºå•å…ƒç»“æ„ä½“ï¼Œç„¶åå†ä¸ºå®ƒå®ç°æŸä¸ªç‰¹å¾
    impl SomeTrait for AlwaysEqual {}
}
```

#### ç»“æ„ä½“æ•°æ®çš„æ‰€æœ‰æƒ

å¦‚æœæƒ³è®©ç»“æ„ä½“ä»å…¶å®ƒå¯¹è±¡å€Ÿç”¨æ•°æ®ï¼Œå°±å¿…é¡»åŠ å…¥**ç”Ÿå‘½å‘¨æœŸ** ï¼Œä¿è¯ç»“æ„ä½“çš„ä½œç”¨èŒƒå›´å°äºå€Ÿç”¨æ•°æ®çš„ä½œç”¨èŒƒå›´ã€‚

```rust
struct User {
    username: &str,
    email: &str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: "someone@example.com",
        username: "someusername123",
        active: true,
        sign_in_count: 1,
    };
}
```

### 2.4.4 æšä¸¾

æšä¸¾(`enum` æˆ– `enumeration`)å…è®¸ä½ é€šè¿‡åˆ—ä¸¾å¯èƒ½çš„æˆå‘˜æ¥å®šä¹‰ä¸€ä¸ª**æšä¸¾ç±»å‹**

```rust
// æ‰‘å…‹èŠ±è‰²
enum PokerSuit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,
}
```

#### æšä¸¾å€¼

åˆ›å»º `PokerSuit` æšä¸¾ç±»å‹çš„ä¸¤ä¸ªæˆå‘˜å®ä¾‹ï¼š

```rust
let heart = PokerSuit::Hearts;
let diamond = PokerSuit::Diamonds;
```

æ‰€ä»¥ä½ å¯ä»¥è¿™æ ·ä½¿ç”¨å®ƒï¼š

```rust
fn main() {
    let heart = PokerSuit::Hearts;
    let diamond = PokerSuit::Diamonds;

    print_suit(heart);
    print_suit(diamond);
}

fn print_suit(card: PokerSuit) {
    println!("{:?}",card);
}
output:
Hearts
Diamonds
```

ä¸ºäº†è®©æšä¸¾æ›´åŠ ä½¿ç”¨ï¼Œ æˆ‘ä»¬å¯ä»¥è¿™æ ·å®šä¹‰æšä¸¾ç±»å‹ï¼Œç›´æ¥å°†æ•°æ®ä¿¡æ¯å…³è”åˆ°æšä¸¾æˆå‘˜ä¸Šï¼š

```rust
enum PokerCard {
    Clubs(u8),
    Spades(u8),
    Diamonds(u8),
    Hearts(u8),
}

fn main() {
    let c1 = PokerCard::Spades(5);
    let c2 = PokerCard::Diamonds(13);
    print_card(c1);
    print_card(c2);
}

fn print_card(card: PokerCard) {
    println!("{:?}", card);
}
output:
Spades(5)
Diamonds(13)
```

#### Option æšä¸¾å¤„ç†ç©ºå€¼

`Rust` æŠ›å¼ƒ `null` ï¼Œä½¿ç”¨ `Option` æšä¸¾å˜é‡æ¥è¡¨è¿°è¿™ç§ç»“æœã€‚

```rust
enum Option<T> {
    Some(T),
    None,
}
```

### 2.4.5 æ•°ç»„

åœ¨ Rust ä¸­ï¼Œæœ€å¸¸ç”¨çš„æ•°ç»„æœ‰ä¸¤ç§ï¼Œç¬¬ä¸€ç§æ˜¯é€Ÿåº¦å¾ˆå¿«ä½†æ˜¯é•¿åº¦å›ºå®šçš„ `array`ï¼Œç¬¬äºŒç§æ˜¯å¯åŠ¨æ€å¢é•¿çš„ä½†æ˜¯æœ‰æ€§èƒ½æŸè€—çš„ `Vector`ã€‚

æ•°ç»„çš„ä¸‰è¦ç´ ï¼š

-   é•¿åº¦å›ºå®š
-   å…ƒç´ å¿…é¡»æœ‰ç›¸åŒçš„ç±»å‹
-   ä¾æ¬¡çº¿æ€§æ’åˆ—

#### åˆ›å»ºæ•°ç»„

```rust
let a = [1, 2, 3, 4, 5];

// å£°æ˜ç±»å‹
let a: [i32; 5] = [1, 2, 3, 4, 5];

// æŸä¸ªå€¼é‡å¤å‡ºç° N æ¬¡çš„æ•°ç»„
let a = [3 ; 5];
```

æ•°ç»„å­˜å‚¨åœ¨æ ˆä¸Šï¼ŒåŠ¨æ€æ•°ç»„å­˜å‚¨åœ¨å †ä¸Šã€‚

#### è®¿é—®æ•°ç»„å…ƒç´ 

æ•°ç»„æ˜¯è¿ç»­å­˜æ”¾å…ƒç´ çš„ï¼Œå› æ­¤å¯ä»¥é€šè¿‡ç´¢å¼•çš„æ–¹å¼æ¥è®¿é—®å­˜æ”¾å…¶ä¸­çš„å…ƒç´ ï¼š

```rust
fn main() {
    let a = [9, 8, 7, 6, 5];

    let first = a[0]; // è·å–aæ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ 
    let second = a[1]; // è·å–ç¬¬äºŒä¸ªå…ƒç´ 
}
```

#### è¶Šç•Œè®¿é—®

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();
    // è¯»å–æ§åˆ¶å°çš„è¾“å‡º
    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!(
        "The value of the element at index {} is: {}",
        index, element
    );
}
```

#### æ•°ç»„åˆ‡ç‰‡

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];

let slice: &[i32] = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

```rust
fn main() {
    // ç¼–è¯‘å™¨è‡ªåŠ¨æ¨å¯¼å‡ºoneçš„ç±»å‹
    let one = [1, 2, 3];
    // æ˜¾å¼ç±»å‹æ ‡æ³¨
    let two: [u8; 3] = [1, 2, 3];
    let blank1 = [0; 3];
    let blank2: [u8; 3] = [0; 3];

    // arraysæ˜¯ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œå…¶ä¸­æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå…ƒç´ ç±»å‹æ˜¯[u8; 3]
    let arrays: [[u8; 3]; 4] = [one, two, blank1, blank2];

    // å€Ÿç”¨arraysçš„å…ƒç´ ç”¨ä½œå¾ªç¯ä¸­
    for a in &arrays {
        print!("{:?}: ", a);
        // å°†aå˜æˆä¸€ä¸ªè¿­ä»£å™¨ï¼Œç”¨äºå¾ªç¯
        // ä½ ä¹Ÿå¯ä»¥ç›´æ¥ç”¨for n in a {}æ¥è¿›è¡Œå¾ªç¯
        for n in a.iter() {
            print!("\t{} + 10 = {}", n, n + 10);
        }

        let mut sum = 0;
        // 0..a.len,æ˜¯ä¸€ä¸ª Rust çš„è¯­æ³•ç³–ï¼Œå…¶å®å°±ç­‰äºä¸€ä¸ªæ•°ç»„ï¼Œå…ƒç´ æ˜¯ä»0,1,2ä¸€ç›´å¢åŠ åˆ°åˆ°a.len-1
        for i in 0..a.len() {
            sum += a[i];
        }
        println!("\t({:?} = {})", a, sum);
    }
}
output:
[1, 2, 3]:      1 + 10 = 11     2 + 10 = 12     3 + 10 = 13     ([1, 2, 3] = 6)
[1, 2, 3]:      1 + 10 = 11     2 + 10 = 12     3 + 10 = 13     ([1, 2, 3] = 6)
[0, 0, 0]:      0 + 10 = 10     0 + 10 = 10     0 + 10 = 10     ([0, 0, 0] = 0)
[0, 0, 0]:      0 + 10 = 10     0 + 10 = 10     0 + 10 = 10     ([0, 0, 0] = 0)
```

## 2.5 æµç¨‹æ§åˆ¶

### `if`åˆ†æ”¯æ§åˆ¶

```rust
if condition == true {
    // A...
} else {
    // B...
}

---------------------------

fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("The value of number is: {}", number);
}
output:
The value of number is: 5
```

### å¾ªç¯æ§åˆ¶

 Rust è¯­è¨€ä¸­æœ‰ä¸‰ç§å¾ªç¯æ–¹å¼ï¼š`for`ã€`while` å’Œ `loop`

#### `for` å¾ªç¯

```rust
fn main() {
    for i in 1..=5 {
        println!("{}",i);
    }
}

---------------------------

for å…ƒç´  in é›†åˆ {
  // ä½¿ç”¨å…ƒç´ å¹²ä¸€äº›ä½ æ‡‚æˆ‘ä¸æ‡‚çš„äº‹æƒ…
}
```

æ€»ç»“ï¼š

| ä½¿ç”¨æ–¹æ³•                      | ç­‰ä»·ä½¿ç”¨æ–¹å¼                                      | æ‰€æœ‰æƒ     |
| ----------------------------- | ------------------------------------------------- | ---------- |
| `for item in collection`      | `for item in IntoIterator::into_iter(collection)` | è½¬ç§»æ‰€æœ‰æƒ |
| `for item in &collection`     | `for item in collection.iter()`                   | ä¸å¯å˜å€Ÿç”¨ |
| `for item in &mut collection` | `for item in collection.iter_mut()`               | å¯å˜å€Ÿç”¨   |

#### `While` å¾ªç¯

```rust
fn main() {
    let mut n = 0;

    while n <= 5  {
        println!("{}!", n);

        n = n + 1;
    }

    println!("æˆ‘å‡ºæ¥äº†ï¼");
}
output:
0!
1!
2!
3!
4!
5!
æˆ‘å‡ºæ¥äº†ï¼
```

#### `loop` å¾ªç¯

 `loop` æ˜¯ä¸€ä¸ªç®€å•çš„æ— é™å¾ªç¯ï¼Œä½ å¯ä»¥åœ¨å†…éƒ¨å®ç°é€»è¾‘é€šè¿‡ `break` å…³é”®å­—æ¥æ§åˆ¶å¾ªç¯ä½•æ—¶ç»“æŸã€‚

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
output:
The result is 20
```

è¿™é‡Œæœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„ï¼š

-   **break å¯ä»¥å•ç‹¬ä½¿ç”¨ï¼Œä¹Ÿå¯ä»¥å¸¦ä¸€ä¸ªè¿”å›å€¼**ï¼Œæœ‰äº›ç±»ä¼¼ `return`
-   **loop æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼**ï¼Œå› æ­¤å¯ä»¥è¿”å›ä¸€ä¸ªå€¼

## 2.6 æ¨¡å¼åŒ¹é…

### 2.6.1 `match` å’Œ `if let`

åœ¨ Rust ä¸­ï¼Œæ¨¡å¼åŒ¹é…æœ€å¸¸ç”¨çš„å°±æ˜¯ `match` å’Œ `if let`

`match` ç±»ä¼¼å…¶ä»–è¯­è¨€ä¸­çš„ `switch`

### `match`å½¢å¼

```rust
match target {
    æ¨¡å¼1 => è¡¨è¾¾å¼1,
    æ¨¡å¼2 => {
        è¯­å¥1;
        è¯­å¥2;
        è¡¨è¾¾å¼2
    },
    _ => è¡¨è¾¾å¼3
}
```

eg :

```rust
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East => println!("East"),
        Direction::North | Direction::South => {
            println!("South or North");
        },
        _ => println!("West"),
    };
}
output: 
South or North
```

ä»¥ä¸‹å‡ ç‚¹å€¼å¾—æ³¨æ„ï¼š

-   `match` çš„åŒ¹é…å¿…é¡»è¦ç©·ä¸¾å‡ºæ‰€æœ‰å¯èƒ½ï¼Œå› æ­¤è¿™é‡Œç”¨ `_` æ¥ä»£è¡¨æœªåˆ—å‡ºçš„æ‰€æœ‰å¯èƒ½æ€§
-   `match` çš„æ¯ä¸€ä¸ªåˆ†æ”¯éƒ½å¿…é¡»æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä¸”æ‰€æœ‰åˆ†æ”¯çš„è¡¨è¾¾å¼æœ€ç»ˆè¿”å›å€¼çš„ç±»å‹å¿…é¡»ç›¸åŒ
-   **X | Y**ï¼Œç±»ä¼¼é€»è¾‘è¿ç®—ç¬¦ `æˆ–`ï¼Œä»£è¡¨è¯¥åˆ†æ”¯å¯ä»¥åŒ¹é… `X` ä¹Ÿå¯ä»¥åŒ¹é… `Y`ï¼Œåªè¦æ»¡è¶³ä¸€ä¸ªå³å¯

>   `_` ç±»ä¼¼äº `switch` ä¸­çš„ `default`

#### ä½¿ç”¨ `match` è¡¨è¾¾å¼èµ‹å€¼

`match` æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå› æ­¤å¯ä»¥ç”¨å®ƒæ¥èµ‹å€¼ï¼š

```rust
enum IpAddr {
   Ipv4,
   Ipv6
}

fn main() {
    // let d_panic = Direction::South;
    let ip1 = IpAddr::Ipv6;
    let ip_str = match ip1 {
        IpAddr::Ipv4 => "127.0.0.1",
        _ => "::1",
    };

    println!("{}", ip_str);
}
output:
::1
```

#### æ¨¡å¼ç»‘å®š

```rust
enum Action {
    Say(String),
    MoveTo(i32, i32),
    ChangeColorRGB(u16, u16, u16),
}

fn main() {
    let actions = [
        Action::Say("Hello Rust".to_string()),
        Action::MoveTo(1,2),
        Action::ChangeColorRGB(255,255,0),
    ];
    for action in actions {
        match action {
            Action::Say(s) => {
                println!("{}", s);
            },
            Action::MoveTo(x, y) => {
                println!("point from (0, 0) move to ({}, {})", x, y);
            },
            Action::ChangeColorRGB(r, g, _) => {
                println!("change color into '(r:{}, g:{}, b:0)', 'b' has been ignored",
                    r, g,
                );
            }
        }
    }
}
output:
Hello Rust
point from (0, 0) move to (1, 2)
change color into '(r:255, g:255, b:0)', 'b' has been ignored
```

#### `if let` åŒ¹é…

å¯¹äºåªæœ‰ä¸€ä¸ªæ¨¡å¼çš„å€¼éœ€è¦è¢«å¤„ç†ï¼Œå…¶å®ƒå€¼ç›´æ¥å¿½ç•¥çš„åœºæ™¯ã€‚

```rust
let v = Some(3u8);
if let Some(3) = v {
    println!("three");
}
```

#### `matches!`å®

å®ƒå¯ä»¥å°†ä¸€ä¸ªè¡¨è¾¾å¼è·Ÿæ¨¡å¼è¿›è¡ŒåŒ¹é…ï¼Œç„¶åè¿”å›åŒ¹é…çš„ç»“æœ `true` or `false`ã€‚

```rust
enum MyEnum {
    Foo,
    Bar
}


fn main() {
    let v = vec![MyEnum::Foo, MyEnum::Bar, MyEnum::Foo];
    v.iter()
        .filter(|x| matches!(x, MyEnum::Foo))
        .for_each(|x| println!("{:?}", x));
}
output:
Foo
Foo
```

#### å˜é‡è¦†ç›–

```rust
fn main() {
   let age = Some(30);
   println!("åœ¨åŒ¹é…å‰ï¼Œageæ˜¯{:?}",age);
   if let Some(age) = age {
       println!("åŒ¹é…å‡ºæ¥çš„ageæ˜¯{}",age);
   }

   println!("åœ¨åŒ¹é…åï¼Œageæ˜¯{:?}",age);
}
output:
åœ¨åŒ¹é…å‰ï¼Œageæ˜¯Some(30)
åŒ¹é…å‡ºæ¥çš„ageæ˜¯30
åœ¨åŒ¹é…åï¼Œageæ˜¯Some(30)
```

å¯ä»¥çœ‹å‡ºåœ¨ `if let` ä¸­ï¼Œ`=` å³è¾¹ `Some(i32)` ç±»å‹çš„ `age` è¢«å·¦è¾¹ `i32` ç±»å‹çš„æ–° `age` è¦†ç›–äº†ï¼Œè¯¥è¦†ç›–ä¸€ç›´æŒç»­åˆ° `if let` è¯­å¥å—çš„ç»“æŸã€‚å› æ­¤ç¬¬ä¸‰ä¸ª `println!` è¾“å‡ºçš„ `age` ä¾ç„¶æ˜¯ `Some(i32)` ç±»å‹ã€‚

### 2.6.2 è§£æ„ `option`

`Option` æšä¸¾ï¼Œç”¨æ¥è§£å†³ Rust ä¸­å˜é‡æ˜¯å¦æœ‰å€¼çš„é—®é¢˜ã€‚

```rust
enum Option<T> {
    Some(T),
    None,
}
```

ç®€å•è§£é‡Šå°±æ˜¯ï¼š**ä¸€ä¸ªå˜é‡è¦ä¹ˆæœ‰å€¼ï¼š`Some(T)`, è¦ä¹ˆä¸ºç©ºï¼š`None`**ã€‚

#### åŒ¹é… `Option<T>`

ä½¿ç”¨ `Option<T>`ï¼Œæ˜¯ä¸ºäº†ä» `Some` ä¸­å–å‡ºå…¶å†…éƒ¨çš„ `T` å€¼ä»¥åŠå¤„ç†æ²¡æœ‰å€¼çš„æƒ…å†µã€‚

```rust
#![allow(unused)]
fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
    println!("{:?}", five);
    println!("{:?}", six);
    println!("{:?}", none);
}
output:
Some(5)
Some(6)
None
```

### 2.6.3 æ¨¡å¼é€‚ç”¨åœºæ™¯

æ¨¡å¼æ˜¯ Rust ä¸­çš„ç‰¹æ®Šè¯­æ³•ï¼Œå®ƒç”¨æ¥åŒ¹é…ç±»å‹ä¸­çš„ç»“æ„å’Œæ•°æ®ï¼Œå®ƒå¾€å¾€å’Œ `match` è¡¨è¾¾å¼è”ç”¨ï¼Œä»¥å®ç°å¼ºå¤§çš„æ¨¡å¼åŒ¹é…èƒ½åŠ›ã€‚æ¨¡å¼ä¸€èˆ¬ç”±ä»¥ä¸‹å†…å®¹ç»„åˆè€Œæˆï¼š

-   å­—é¢å€¼
-   è§£æ„çš„æ•°ç»„ã€æšä¸¾ã€ç»“æ„ä½“æˆ–è€…å…ƒç»„
-   å˜é‡
-   é€šé…ç¬¦
-   å ä½ç¬¦

#### `match` åˆ†æ”¯

```rust
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    _ => EXPRESSION,
}
```

#### `if let` åˆ†æ”¯

```rust
if let PATTERN = SOME_VALUE {

}
```

#### `while let` åˆ†æ”¯

ä¸€ä¸ªä¸ `if let` ç±»ä¼¼çš„ç»“æ„æ˜¯ `while let` æ¡ä»¶å¾ªç¯ï¼Œå®ƒå…è®¸åªè¦æ¨¡å¼åŒ¹é…å°±ä¸€ç›´è¿›è¡Œ `while` å¾ªç¯ã€‚

eg:

```rust
#![allow(unused)]
fn main() {
    // Vecæ˜¯åŠ¨æ€æ•°ç»„
    let mut stack = Vec::new();

    // å‘æ•°ç»„å°¾éƒ¨æ’å…¥å…ƒç´ 
    stack.push(1);
    stack.push(2);
    stack.push(3);

    // stack.popä»æ•°ç»„å°¾éƒ¨å¼¹å‡ºå…ƒç´ 
    while let Some(top) = stack.pop() {
        println!("{}", top);
    }
}
output:
3
2
1
```

ä¸€æ—¦å…¶è¿”å› `None`ï¼Œ`while` å¾ªç¯åœæ­¢ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `while let` æ¥å¼¹å‡ºæ ˆä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ã€‚

#### `for` å¾ªç¯

```rust
#![allow(unused)]
fn main() {
    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{} is at index {}", value, index);
    }
}
output:
a is at index 0
b is at index 1
c is at index 2
```

è¿™é‡Œä½¿ç”¨ `enumerate` æ–¹æ³•äº§ç”Ÿä¸€ä¸ªè¿­ä»£å™¨ï¼Œè¯¥è¿­ä»£å™¨æ¯æ¬¡è¿­ä»£ä¼šè¿”å›ä¸€ä¸ª `(ç´¢å¼•ï¼Œå€¼)` å½¢å¼çš„å…ƒç»„ï¼Œç„¶åç”¨ `(index,value)` æ¥åŒ¹é…ã€‚

#### `let` è¯­å¥

#### å‡½æ•°å‚æ•°

### 2.6.4 å…¨æ¨¡å¼åŒ¹é…

#### åŒ¹é…å­—é¢å€¼

```rust
#![allow(unused)]
fn main() {
    let x = 1;

    match x {
        1 => println!("one"),
        2 => println!("two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
}
output:
one
```

#### åŒ¹é…å‘½åå˜é‡

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {:?}", y),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);
}
output:
Matched, y = 5
at the end: x = Some(5), y = 10
```

#### å•åˆ†æ”¯å¤šæ¨¡å¼

```rust
#![allow(unused)]
fn main() {
    let x = 1;

    match x {
        1 | 2 => println!("one or two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
}
output:
one or two
```

#### é€šè¿‡åºåˆ— `..=` åŒ¹é…å€¼çš„èŒƒå›´

```rust
#![allow(unused)]
fn main() {
    let x = 5;

    match x {
        1..=5 => println!("one through five"),
        _ => println!("something else"),
    }
}
output:
one through five
```

#### è§£æ„å¹¶åˆ†è§£å€¼

å¯ä»¥ä½¿ç”¨æ¨¡å¼æ¥è§£æ„ç»“æ„ä½“ã€æšä¸¾ã€å…ƒç»„å’Œå¼•ç”¨

##### è§£æ„ç»“æ„ä½“

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}

--------------------------------------
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
}
output:
On the y axis at 7
```

##### è§£æ„æšä¸¾

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        Message::Move { x, y } => {
            println!("Move in the x direction {} and in the y direction {}", x, y);
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!("Change the color to red {}, green {}, and blue {}", r, g, b)
        }
    }
}
output:
Change the color to red 0, green 160, and blue 255
```

##### è§£æ„åµŒå¥—çš„ç»“æ„ä½“å’Œæšä¸¾

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!("Change the color to red {}, green {}, and blue {}", r, g, b)
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!(
                "Change the color to hue {}, saturation {}, and value {}",
                h, s, v
            )
        }
        _ => (),
    }
}
output:
Change the color to hue 0, saturation 160, and value 255
```

##### è§£æ„ç»“æ„ä½“å’Œå…ƒç»„

```rust
#![allow(unused)]
fn main() {
    struct Point {
        x: i32,
        y: i32,
    }

    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
    println!("feet => {:?}, inches => {:?}", feet, inches);
    println!("point.x => {:?}, point.y => {:?}", x, y);
}
output:
feet => 3, inches => 10
point.x => 3, point.y => -10
```

#### å¿½ç•¥æ¨¡å¼ä¸­çš„å€¼

##### ä½¿ç”¨ `_` å¿½ç•¥æ•´ä¸ªå€¼

```rust
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}

fn main() {
    foo(3, 4);
}
output:
This code only uses the y parameter: 4
```

ä½¿ç”¨åµŒå¥—çš„ `_` å¿½ç•¥éƒ¨åˆ†å€¼

```rust
#![allow(unused)]
fn main() {
    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) => {
            println!("Can't overwrite an existing customized value");
        }
        _ => {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {:?}", setting_value);
}
output:
Can't overwrite an existing customized value
setting is Some(5)
```

##### ä½¿ç”¨ä¸‹åˆ’çº¿å¼€å¤´å¿½ç•¥æœªä½¿ç”¨çš„å˜é‡

```rust
#![allow(unused)]
fn main() {
    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{:?}", s);
}
```

åªä½¿ç”¨ `_` å’Œä½¿ç”¨ä»¥ä¸‹åˆ’çº¿å¼€å¤´çš„åç§°æœ‰äº›å¾®å¦™çš„ä¸åŒï¼šæ¯”å¦‚ **`_x` ä»ä¼šå°†å€¼ç»‘å®šåˆ°å˜é‡ï¼Œè€Œ `_` åˆ™å®Œå…¨ä¸ä¼šç»‘å®š**ã€‚

##### ç”¨ `..` å¿½ç•¥å‰©ä½™å€¼

```rust
#![allow(unused)]
fn main() {
    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } => println!("x is {}", x),
    }
}
output:
x is 0
```

#### åŒ¹é…å®ˆå«æä¾›çš„é¢å¤–æ¡ä»¶

**åŒ¹é…å®ˆå«**ï¼ˆ*match guard*ï¼‰æ˜¯ä¸€ä¸ªä½äº `match` åˆ†æ”¯æ¨¡å¼ä¹‹åçš„é¢å¤– `if` æ¡ä»¶ï¼Œå®ƒèƒ½ä¸ºåˆ†æ”¯æ¨¡å¼æä¾›æ›´è¿›ä¸€æ­¥çš„åŒ¹é…æ¡ä»¶ã€‚

```rust
#![allow(unused)]
fn main() {
    // let num = Some(4);
    let num = Some(10);

    match num {
        Some(x) if x < 5 => println!("less than five: {}", x),
        Some(x) => println!("{}", x),
        None => (),
    }
}
output:
10
```

#### @ç»‘å®š

`@`è¿ç®—ç¬¦å…è®¸ä¸ºä¸€ä¸ªå­—æ®µç»‘å®šå¦å¤–ä¸€ä¸ªå˜é‡ã€‚

å½“ä½ æ—¢æƒ³è¦é™å®šåˆ†æ”¯èŒƒå›´ï¼Œåˆæƒ³è¦ä½¿ç”¨åˆ†æ”¯çš„å˜é‡æ—¶ï¼Œå°±å¯ä»¥ç”¨ `@` æ¥ç»‘å®šåˆ°ä¸€ä¸ªæ–°çš„å˜é‡ä¸Šï¼Œå®ç°æƒ³è¦çš„åŠŸèƒ½ã€‚

```rust
#![allow(unused)]
fn main() {
    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } => {
            println!("Found an id in range: {}", id_variable)
        }
        Message::Hello { id: 10..=12 } => {
            println!("Found an id in another range")
        }
        Message::Hello { id } => {
            println!("Found some other id: {}", id)
        }
    }
}
output:
Found an id in range: 5
```

##### @å‰ç»‘å®šåè§£æ„(Rust 1.56 æ–°å¢)

ä½¿ç”¨ `@` è¿˜å¯ä»¥åœ¨ç»‘å®šæ–°å˜é‡çš„åŒæ—¶ï¼Œå¯¹ç›®æ ‡è¿›è¡Œè§£æ„ï¼š

```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    // ç»‘å®šæ–°å˜é‡ `p`ï¼ŒåŒæ—¶å¯¹ `Point` è¿›è¡Œè§£æ„
    let p @ Point { x: px, y: py } = Point { x: 10, y: 23 };
    println!("x: {}, y: {}", px, py);
    println!("{:?}", p);

    let point = Point { x: 10, y: 5 };
    if let p @ Point { x: 10, y } = point {
        println!("x is 10 and y is {} in {:?}", y, p);
    } else {
        println!("x was not 10 :(");
    }
}
output:
x: 10, y: 23
Point { x: 10, y: 23 }
x is 10 and y is 5 in Point { x: 10, y: 5 }
```

