## 2.1 变量绑定与解构

### 为何 `Rust` 选择了手动设定变量的可变性

一般来说，变量一旦创建，要么可变（灵活）或者不可变（安全），而 `Rust` 的变量两者都具有。

### 变量绑定

```rust
let a = "akira"
```

### 变量可变性

`Rust` 的变量在默认情况下是***不可变的***，可以通过 `mut` 关键字让变量变为***可变的***

编写代码：

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

保存并运行：

```bash
$ cargo run          
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
```

具体的错误原因是 `cannot assign twice to immutable variable x`

修改代码：

```rust
let mut x = 5;
```

再次运行：

```bash
$ cargo run
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

可变还是不可变，更多的还是取决于你的使用场景：灵活与安全之间的抉择。可变变量最大的好处就是使用上的灵活性和性能上的提升。

### 变量解构

`let` 表达式用于变量的绑定，进行复杂变量的解构。

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,不可变; b = false，可变
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

### 解构式赋值

```rust
let (a, b, c, d, e);

    (a, b) = (1, 2);
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
```

>   这种使用方式跟之前的 `let` 保持了一致性，但是 `let` 会重新绑定，而这里仅仅是对之前绑定的变量进行再赋值。
>
>   使用 `+=` 的赋值语句还不支持解构式赋值

### 变量与常量之间的差异

-   常量不允许使用 `mut`。**常量不仅仅默认不可变，而且自始至终不可变**，因为常量在编译完成后，已经确定它的值。
-   常量使用 `const` 关键字而不是 `let` 关键字来声明，并且值的类型**必须**标注。

### 变量遮蔽(shadowing)

`Rust` 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的:

```rust
fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;

    {
        // 在当前的花括号作用域内，对之前的x进行遮蔽
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```

运行：

```bash
$ cargo run
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `./variables`
var shadowing
The value of x in the inner scope is: 12
The value of x is: 6
```

>   多次的`let`声明了多个同名变量，使用更多内存
>
>   `mut`只是修改同一内存地址上的值，不会发生内存对象的再分配，性能要更好

变量遮蔽的作用：
如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），可以重复的使用变量名字