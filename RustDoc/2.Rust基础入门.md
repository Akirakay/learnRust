## 2.1 å˜é‡ç»‘å®šä¸è§£æ„

### ä¸ºä½• `Rust` é€‰æ‹©äº†æ‰‹åŠ¨è®¾å®šå˜é‡çš„å¯å˜æ€§

ä¸€èˆ¬æ¥è¯´ï¼Œå˜é‡ä¸€æ—¦åˆ›å»ºï¼Œè¦ä¹ˆå¯å˜ï¼ˆçµæ´»ï¼‰æˆ–è€…ä¸å¯å˜ï¼ˆå®‰å…¨ï¼‰ï¼Œè€Œ `Rust` çš„å˜é‡ä¸¤è€…éƒ½å…·æœ‰ã€‚

### å˜é‡ç»‘å®š

```rust
let a = "akira"
```

### å˜é‡å¯å˜æ€§

`Rust` çš„å˜é‡åœ¨é»˜è®¤æƒ…å†µä¸‹æ˜¯***ä¸å¯å˜çš„***ï¼Œå¯ä»¥é€šè¿‡ `mut` å…³é”®å­—è®©å˜é‡å˜ä¸º***å¯å˜çš„***

ç¼–å†™ä»£ç ï¼š

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

ä¿å­˜å¹¶è¿è¡Œï¼š

```bash
$ cargo run          
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
```

å…·ä½“çš„é”™è¯¯åŸå› æ˜¯ `cannot assign twice to immutable variable x`

ä¿®æ”¹ä»£ç ï¼š

```rust
let mut x = 5;
```

å†æ¬¡è¿è¡Œï¼š

```bash
$ cargo run
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

å¯å˜è¿˜æ˜¯ä¸å¯å˜ï¼Œæ›´å¤šçš„è¿˜æ˜¯å–å†³äºä½ çš„ä½¿ç”¨åœºæ™¯ï¼šçµæ´»ä¸å®‰å…¨ä¹‹é—´çš„æŠ‰æ‹©ã€‚å¯å˜å˜é‡æœ€å¤§çš„å¥½å¤„å°±æ˜¯ä½¿ç”¨ä¸Šçš„çµæ´»æ€§å’Œæ€§èƒ½ä¸Šçš„æå‡ã€‚

### å˜é‡è§£æ„

`let` è¡¨è¾¾å¼ç”¨äºå˜é‡çš„ç»‘å®šï¼Œä¹Ÿå¯ä»¥è¿›è¡Œå¤æ‚å˜é‡çš„è§£æ„ã€‚

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,ä¸å¯å˜; b = falseï¼Œå¯å˜
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

### è§£æ„å¼èµ‹å€¼

```rust
let (a, b, c, d, e);

    (a, b) = (1, 2);
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
```

>   è¿™ç§ä½¿ç”¨æ–¹å¼è·Ÿä¹‹å‰çš„ `let` ä¿æŒäº†ä¸€è‡´æ€§ï¼Œä½†æ˜¯ `let` ä¼šé‡æ–°ç»‘å®šï¼Œè€Œè¿™é‡Œä»…ä»…æ˜¯å¯¹ä¹‹å‰ç»‘å®šçš„å˜é‡è¿›è¡Œå†èµ‹å€¼ã€‚
>
>   ä½¿ç”¨ `+=` çš„èµ‹å€¼è¯­å¥è¿˜ä¸æ”¯æŒè§£æ„å¼èµ‹å€¼

### å˜é‡ä¸å¸¸é‡ä¹‹é—´çš„å·®å¼‚

-   å¸¸é‡ä¸å…è®¸ä½¿ç”¨ `mut`ã€‚**å¸¸é‡ä¸ä»…ä»…é»˜è®¤ä¸å¯å˜ï¼Œè€Œä¸”è‡ªå§‹è‡³ç»ˆä¸å¯å˜**ï¼Œå› ä¸ºå¸¸é‡åœ¨ç¼–è¯‘å®Œæˆåï¼Œå·²ç»ç¡®å®šå®ƒçš„å€¼ã€‚
-   å¸¸é‡ä½¿ç”¨ `const` å…³é”®å­—è€Œä¸æ˜¯ `let` å…³é”®å­—æ¥å£°æ˜ï¼Œå¹¶ä¸”å€¼çš„ç±»å‹**å¿…é¡»**æ ‡æ³¨ã€‚

### å˜é‡é®è”½(shadowing)

`Rust` å…è®¸å£°æ˜ç›¸åŒçš„å˜é‡åï¼Œåœ¨åé¢å£°æ˜çš„å˜é‡ä¼šé®è”½æ‰å‰é¢å£°æ˜çš„:

```rust
fn main() {
    let x = 5;
    // åœ¨mainå‡½æ•°çš„ä½œç”¨åŸŸå†…å¯¹ä¹‹å‰çš„xè¿›è¡Œé®è”½
    let x = x + 1;

    {
        // åœ¨å½“å‰çš„èŠ±æ‹¬å·ä½œç”¨åŸŸå†…ï¼Œå¯¹ä¹‹å‰çš„xè¿›è¡Œé®è”½
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```

è¿è¡Œï¼š

```bash
$ cargo run
   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `./variables`
var shadowing
The value of x in the inner scope is: 12
The value of x is: 6
```

>   å¤šæ¬¡çš„`let`å£°æ˜äº†å¤šä¸ªåŒåå˜é‡ï¼Œä½¿ç”¨æ›´å¤šå†…å­˜
>
>   `mut`åªæ˜¯ä¿®æ”¹åŒä¸€å†…å­˜åœ°å€ä¸Šçš„å€¼ï¼Œä¸ä¼šå‘ç”Ÿå†…å­˜å¯¹è±¡çš„å†åˆ†é…ï¼Œæ€§èƒ½è¦æ›´å¥½

å˜é‡é®è”½çš„ä½œç”¨ï¼š
å¦‚æœä½ åœ¨æŸä¸ªä½œç”¨åŸŸå†…æ— éœ€å†ä½¿ç”¨ä¹‹å‰çš„å˜é‡ï¼ˆåœ¨è¢«é®è”½åï¼Œæ— æ³•å†è®¿é—®åˆ°ä¹‹å‰çš„åŒåå˜é‡ï¼‰ï¼Œå¯ä»¥é‡å¤çš„ä½¿ç”¨å˜é‡åå­—

## 2.2 åŸºæœ¬ç±»å‹

-   æ•°å€¼ç±»å‹: æœ‰ç¬¦å·æ•´æ•° (`i8`, `i16`, `i32`, `i64`, `isize`)ã€ æ— ç¬¦å·æ•´æ•° (`u8`, `u16`, `u32`, `u64`, `usize`) ã€æµ®ç‚¹æ•° (`f32`, `f64`)ã€ä»¥åŠæœ‰ç†æ•°ã€å¤æ•°
-   å­—ç¬¦ä¸²ï¼šå­—ç¬¦ä¸²å­—é¢é‡å’Œå­—ç¬¦ä¸²åˆ‡ç‰‡ `&str`
-   å¸ƒå°”ç±»å‹ï¼š `true`å’Œ`false`
-   å­—ç¬¦ç±»å‹: è¡¨ç¤ºå•ä¸ª Unicode å­—ç¬¦ï¼Œå­˜å‚¨ä¸º 4 ä¸ªå­—èŠ‚
-   å•å…ƒç±»å‹: å³ `()` ï¼Œå…¶å”¯ä¸€çš„å€¼ä¹Ÿæ˜¯ `()`

`Rust` æ˜¯ä¸€é—¨**é™æ€ç±»å‹**è¯­è¨€ï¼Œä¹Ÿå°±æ˜¯ç¼–è¯‘å™¨å¿…é¡»åœ¨ç¼–è¯‘æœŸçŸ¥é“æˆ‘ä»¬æ‰€æœ‰å˜é‡çš„ç±»å‹ï¼Œä½†è¿™ä¸æ„å‘³ç€ä½ éœ€è¦ä¸ºæ¯ä¸ªå˜é‡æŒ‡å®šç±»å‹ï¼Œå› ä¸º **Rust ç¼–è¯‘å™¨å¾ˆèªæ˜ï¼Œå®ƒå¯ä»¥æ ¹æ®å˜é‡çš„å€¼å’Œä¸Šä¸‹æ–‡ä¸­çš„ä½¿ç”¨æ–¹å¼æ¥è‡ªåŠ¨æ¨å¯¼å‡ºå˜é‡çš„ç±»å‹**

### 2.2.1 æ•°å€¼ç±»å‹

#### æ•´æ•°ç±»å‹

ç±»å‹å®šä¹‰çš„å½¢å¼ç»Ÿä¸€ä¸ºï¼š`æœ‰æ— ç¬¦å· + ç±»å‹å¤§å°(ä½æ•°)`

 eg: 

æœ‰ç¬¦å·ç±»å‹ï¼ši8ï¼Œi16ï¼Œi32ï¼ˆé»˜è®¤ç±»å‹ï¼‰ï¼Œi64ï¼Œi128ï¼Œisizeï¼ˆè§†æ¶æ„è€Œå®šï¼‰

æ— ç¬¦å·ç±»å‹ï¼šu8ï¼Œu16ï¼Œu32ï¼Œu64ï¼Œu128ï¼Œusizeï¼ˆè§†æ¶æ„è€Œå®šï¼‰

>æ•´å‹æº¢å‡ºï¼š
>
>debug æ¨¡å¼ä¸‹ä¼šæ£€æµ‹æ•°å€¼æº¢å‡ºï¼Œé€ æˆç¼–è¯‘å¤±è´¥ï¼ˆ`panic`ï¼‰
>
>--release æ¨¡å¼ä¸‹ä¸ä¼šæ£€æµ‹æº¢å‡ºï¼ŒRust ä¼šæŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºï¼ˆ*twoâ€™s complement wrapping*ï¼‰çš„è§„åˆ™å¤„ç†
>
>è¦æ˜¾å¼å¤„ç†å¯èƒ½çš„æº¢å‡ºï¼Œå¯ä»¥ä½¿ç”¨æ ‡å‡†åº“é’ˆå¯¹åŸå§‹æ•°å­—ç±»å‹æä¾›çš„è¿™äº›æ–¹æ³•ï¼š
>
>-   ä½¿ç”¨ `wrapping_*` æ–¹æ³•åœ¨æ‰€æœ‰æ¨¡å¼ä¸‹éƒ½æŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºè§„åˆ™å¤„ç†ï¼Œä¾‹å¦‚ `wrapping_add`
>-   å¦‚æœä½¿ç”¨ `checked_*` æ–¹æ³•æ—¶å‘ç”Ÿæº¢å‡ºï¼Œåˆ™è¿”å› `None` å€¼
>-   ä½¿ç”¨ `overflowing_*` æ–¹æ³•è¿”å›è¯¥å€¼å’Œä¸€ä¸ªæŒ‡ç¤ºæ˜¯å¦å­˜åœ¨æº¢å‡ºçš„å¸ƒå°”å€¼
>-   ä½¿ç”¨ `saturating_*` æ–¹æ³•ä½¿å€¼è¾¾åˆ°æœ€å°å€¼æˆ–æœ€å¤§å€¼

#### æµ®ç‚¹ç±»å‹

ä¸¤ç§åŸºæœ¬ç±»å‹ï¼š `f32` å’Œ `f64`ï¼ˆé»˜è®¤ï¼‰

#### NaN

å¯¹äºæ•°å­¦ä¸Šæœªå®šä¹‰çš„ç»“æœï¼Œä½¿ç”¨`NaN`æ¥å¤„ç†

å¯ä»¥ä½¿ç”¨ `is_nan()` ç­‰æ–¹æ³•ï¼Œå¯ä»¥ç”¨æ¥åˆ¤æ–­ä¸€ä¸ªæ•°å€¼æ˜¯å¦æ˜¯ `NaN` 

#### åºåˆ—ï¼ˆ`Range`ï¼‰

åºåˆ—åªå…è®¸ç”¨äºæ•°å­—æˆ–å­—ç¬¦ç±»å‹ï¼ŒåŸå› æ˜¯ï¼šå®ƒä»¬å¯ä»¥è¿ç»­ã€‚

eg:

```rust
for i in 1..=5 {
    println!("{}",i);
}
output: 
1
2
3
4
5
```

#### æ€»ç»“ï¼š

-   **Rust æ‹¥æœ‰ç›¸å½“å¤šçš„æ•°å€¼ç±»å‹**. ç†Ÿæ‚‰ç±»å‹å ç”¨çš„å­—èŠ‚æ•°ä¸èŒƒå›´
-   **ç±»å‹è½¬æ¢å¿…é¡»æ˜¯æ˜¾å¼çš„**
-   **Rust çš„æ•°å€¼ä¸Šå¯ä»¥ä½¿ç”¨æ–¹æ³•**. ä¾‹å¦‚ä½ å¯ä»¥ç”¨ä»¥ä¸‹æ–¹æ³•æ¥å°† `13.14` å–æ•´ï¼š`13.14_f32.round()`



### 2.2.2 å­—ç¬¦ã€å¸ƒå°”ã€å•å…ƒç±»å‹

#### å­—ç¬¦ç±»å‹

Rust çš„å­—ç¬¦ä¸ä»…ä»…æ˜¯ `ASCII`ï¼Œæ‰€æœ‰çš„ `Unicode` å€¼éƒ½å¯ä»¥ä½œä¸º Rust å­—ç¬¦ã€‚

```rust
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let g = 'å›½';
    let heart_eyed_cat = 'ğŸ˜»';
}
```

>   Rust çš„å­—ç¬¦åªèƒ½ç”¨ `''` æ¥è¡¨ç¤ºï¼Œ `""` æ˜¯ç•™ç»™å­—ç¬¦ä¸²çš„

#### å¸ƒå°”ï¼ˆboolï¼‰

å¸ƒå°”ç±»å‹æœ‰ä¸¤ä¸ªå¯èƒ½çš„å€¼ï¼š`true` å’Œ `false`ï¼Œå¤§å°ä¸º `1` ä¸ªå­—èŠ‚ï¼š

```rust
fn main() {
    let t = true;

    let f: bool = false; // ä½¿ç”¨ç±»å‹æ ‡æ³¨,æ˜¾å¼æŒ‡å®šfçš„ç±»å‹

    if f {
        println!("è¿™æ˜¯æ®µæ¯«æ— æ„ä¹‰çš„ä»£ç ");
    }
}
```

#### å•å…ƒç±»å‹

å•å…ƒç±»å‹å°±æ˜¯ `()`ï¼Œå”¯ä¸€çš„å€¼ä¹Ÿæ˜¯ `()` ã€‚

`main` å‡½æ•°å°±è¿”å›è¿™ä¸ªå•å…ƒç±»å‹ `()`

æ²¡æœ‰è¿”å›å€¼çš„å‡½æ•°åœ¨ Rust ä¸­æ˜¯æœ‰å•ç‹¬çš„å®šä¹‰çš„ï¼š`å‘æ•£å‡½æ•°`

### 2.2.3 è¯­å¥å’Œè¡¨è¾¾å¼

Rust çš„å‡½æ•°ä½“æ˜¯ç”±ä¸€ç³»åˆ—è¯­å¥ç»„æˆï¼Œæœ€åç”±ä¸€ä¸ªè¡¨è¾¾å¼æ¥è¿”å›å€¼ï¼Œä¾‹å¦‚ï¼š

```rust
fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // è¯­å¥
    let y = y + 5; // è¯­å¥
    x + y // è¡¨è¾¾å¼
}
```

è¡¨è¾¾å¼ä¼šåœ¨æ±‚å€¼åè¿”å›ä¸€ä¸ªå€¼

### 2.2.4 å‡½æ•°

![img](https://s2.loli.net/2022/03/10/nD7mvPi43Xpe9Of.png)

#### å‡½æ•°è¦ç‚¹

-   å‡½æ•°åå’Œå˜é‡åä½¿ç”¨ `snake case` ä¾‹å¦‚ `fn add_two() -> {}`
-   å‡½æ•°çš„ä½ç½®å¯ä»¥éšä¾¿æ”¾ï¼ŒRust ä¸å…³å¿ƒæˆ‘ä»¬åœ¨å“ªé‡Œå®šä¹‰äº†å‡½æ•°ï¼Œåªè¦æœ‰å®šä¹‰å³å¯
-   æ¯ä¸ªå‡½æ•°å‚æ•°éƒ½éœ€è¦æ ‡æ³¨ç±»å‹

#### å‡½æ•°è¿”å›

å‡½æ•°çš„è¿”å›å€¼å°±æ˜¯å‡½æ•°ä½“æœ€åä¸€æ¡è¡¨è¾¾å¼çš„è¿”å›å€¼ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ `return` æå‰è¿”å›ã€‚

#### `Rust` ä¸­ç‰¹æ®Šçš„è¿”å›ç±»å‹

##### æ— è¿”å›å€¼ `()`

å•å…ƒç±»å‹ `()`ï¼Œæ˜¯ä¸€ä¸ªé›¶é•¿åº¦çš„å…ƒç»„ã€‚å®ƒæ²¡å•¥ä½œç”¨ï¼Œä½†æ˜¯å¯ä»¥ç”¨æ¥è¡¨è¾¾ä¸€ä¸ªå‡½æ•°æ²¡æœ‰è¿”å›å€¼ï¼š

-   å‡½æ•°æ²¡æœ‰è¿”å›å€¼ï¼Œé‚£ä¹ˆè¿”å›ä¸€ä¸ª `()`
-   é€šè¿‡ `;` ç»“å°¾çš„è¡¨è¾¾å¼è¿”å›ä¸€ä¸ª `()`

##### æ°¸ä¸è¿”å›çš„å‡½æ•° `!`

ç”¨ `!` ä½œå‡½æ•°è¿”å›ç±»å‹çš„æ—¶å€™ï¼Œè¡¨ç¤ºè¯¥å‡½æ•°æ°¸ä¸è¿”å›

eg:

```rust
fn forever() -> ! {
  loop {
    //...
  };
}
```

## 2.3 æ‰€æœ‰æƒä¸å€Ÿç”¨â­ï¸

### 2.3.1 æ‰€æœ‰æƒ

å¦‚ä½•ç®¡ç†ç³»ç»Ÿå†…å­˜ï¼š

-   **åƒåœ¾å›æ”¶æœºåˆ¶(GC)**ï¼Œåœ¨ç¨‹åºè¿è¡Œæ—¶ä¸æ–­å¯»æ‰¾ä¸å†ä½¿ç”¨çš„å†…å­˜ï¼Œå…¸å‹ä»£è¡¨ï¼šJavaã€Go
-   **æ‰‹åŠ¨ç®¡ç†å†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾**, åœ¨ç¨‹åºä¸­ï¼Œé€šè¿‡å‡½æ•°è°ƒç”¨çš„æ–¹å¼æ¥ç”³è¯·å’Œé‡Šæ”¾å†…å­˜ï¼Œå…¸å‹ä»£è¡¨ï¼šC++
-   **é€šè¿‡æ‰€æœ‰æƒæ¥ç®¡ç†å†…å­˜**ï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶ä¼šæ ¹æ®ä¸€ç³»åˆ—è§„åˆ™è¿›è¡Œæ£€æŸ¥

é€šè¿‡æ‰€æœ‰æƒæ¥ç®¡ç†å†…å­˜æ£€æŸ¥åªå‘ç”Ÿåœ¨ç¼–è¯‘æœŸï¼Œè¿è¡ŒæœŸä¸ä¼šæœ‰æ€§èƒ½æŸè€—

#### æ‰€æœ‰æƒåŸåˆ™

1.  Rust ä¸­æ¯ä¸€ä¸ªå€¼éƒ½ `æœ‰ä¸”åªæœ‰` ä¸€ä¸ªæ‰€æœ‰è€…(å˜é‡)
2.  å½“æ‰€æœ‰è€…(å˜é‡)ç¦»å¼€ä½œç”¨åŸŸèŒƒå›´æ—¶ï¼Œè¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒ(drop)

å¯¹äºç®€å•ç±»å‹çš„å˜é‡ï¼šæ ˆä¸Šç›´æ¥å°†æ•°æ®æ‹·è´ï¼Œèµ‹å€¼ç»™æ–°å˜é‡

å¯¹äºå¤æ‚ç±»å‹çš„å˜é‡ï¼šå¤æ‚å¯¹è±¡çš„æŒ‡é’ˆèµ‹å€¼ç»™æ–°çš„å˜é‡ä¼šå¯¼è‡´æ—§çš„æŒ‡é’ˆå˜é‡å¤±æ•ˆ => å¯¹æ­¤å¤æ‚å¯¹è±¡çš„æ‰€æœ‰æƒè½¬ç§»

>   ä»¥ `String` ä¸ºä¾‹æ€è€ƒï¼š
>
>   `String` ç±»å‹æŒ‡å‘äº†ä¸€ä¸ªå †ä¸Šçš„ç©ºé—´ï¼Œå­˜å‚¨ç€å®ƒçš„çœŸå®æ•°æ®, å¯¹äºä»£ç ä¸­çš„ `let s2 = s1` åˆ†æˆä¸¤ç§æƒ…å†µè®¨è®ºï¼š
>
>   1.  æ‹·è´ `String` å’Œå­˜å‚¨åœ¨å †ä¸Šçš„å­—èŠ‚æ•°ç»„ å¦‚æœè¯¥è¯­å¥æ˜¯æ‹·è´æ‰€æœ‰æ•°æ®(æ·±æ‹·è´)ï¼Œé‚£ä¹ˆæ— è®ºæ˜¯ `String` æœ¬èº«è¿˜æ˜¯åº•å±‚çš„å †ä¸Šæ•°æ®ï¼Œéƒ½ä¼šè¢«å…¨éƒ¨æ‹·è´ï¼Œè¿™å¯¹äºæ€§èƒ½è€Œè¨€ä¼šé€ æˆéå¸¸å¤§çš„å½±å“
>   2.  åªæ‹·è´ `String` æœ¬èº« è¿™æ ·çš„æ‹·è´éå¸¸å¿«ï¼Œå› ä¸ºåœ¨ 64 ä½æœºå™¨ä¸Šå°±æ‹·è´äº† `8å­—èŠ‚çš„æŒ‡é’ˆ`ã€`8å­—èŠ‚çš„é•¿åº¦`ã€`8å­—èŠ‚çš„å®¹é‡`ï¼Œæ€»è®¡ 24 å­—èŠ‚ï¼Œä½†æ˜¯å¸¦æ¥äº†æ–°çš„é—®é¢˜ï¼Œæ ¹æ®æ‰€æœ‰æƒè§„åˆ™ï¼Œå…¶ä¸­ä¸€æ¡ï¼š**ä¸€ä¸ªå€¼åªå…è®¸æœ‰ä¸€ä¸ªæ‰€æœ‰è€…**ï¼Œè€Œç°åœ¨è¿™ä¸ªå€¼ï¼ˆå †ä¸Šçš„çœŸå®å­—ç¬¦ä¸²æ•°æ®ï¼‰æœ‰äº†ä¸¤ä¸ªæ‰€æœ‰è€…ï¼š`s1` å’Œ `s2`ã€‚å‡å®šä¸€ä¸ªå€¼å¯ä»¥æ‹¥æœ‰ä¸¤ä¸ªæ‰€æœ‰è€…ï¼Œå°±ä¼šå¯¼è‡´ **äºŒæ¬¡é‡Šæ”¾ï¼ˆdouble freeï¼‰** çš„é”™è¯¯ã€‚

eg:

```rust
#![allow(unused)]
fn main() {
  let s1 = String::from("hello");
  let s2 = s1;
	println!("{}, world!", s1);
}
output:
error[E0382]: use of moved value: `s1`
 --> src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
```

â—ï¸æ­¤æ—¶å†æ€è€ƒ **å˜é‡ç»‘å®š** ä¸ **å˜é‡èµ‹å€¼ **è¯­ä¹‰ä¸Šçš„åŒºåˆ«

#### å…‹éš†ï¼ˆæ·±æ‹·è´ï¼‰

**Rust æ°¸è¿œä¹Ÿä¸ä¼šè‡ªåŠ¨åˆ›å»ºæ•°æ®çš„ â€œæ·±æ‹·è´â€**  => ä»»ä½•**è‡ªåŠ¨**çš„å¤åˆ¶éƒ½ä¸æ˜¯æ·±æ‹·è´

 ä½¿ç”¨ `clone()` è¿›è¡Œæ·±æ‹·è´

eg:

```rust
#![allow(unused)]
fn main() {
  let s1 = String::from("hello");
  let s2 = s1.clone();

  println!("s1 = {}, s2 = {}", s1, s2);
}
output:
s1 = hello, s2 = hello
```

#### æ‹·è´ï¼ˆæµ…æ‹·è´ï¼‰

æµ…æ‹·è´åªå‘ç”Ÿåœ¨æ ˆ

Rust æœ‰ä¸€ä¸ªå«åš `Copy` çš„ç‰¹å¾ï¼Œå¯ä»¥ç”¨åœ¨ç±»ä¼¼æ•´å‹è¿™æ ·åœ¨æ ˆä¸­å­˜å‚¨çš„ç±»å‹ã€‚å¦‚æœä¸€ä¸ªç±»å‹æ‹¥æœ‰ `Copy` ç‰¹å¾ï¼Œä¸€ä¸ªæ—§çš„å˜é‡åœ¨è¢«èµ‹å€¼ç»™å…¶ä»–å˜é‡åä»ç„¶å¯ç”¨ã€‚

 **ä»»ä½•åŸºæœ¬ç±»å‹çš„ç»„åˆå¯ä»¥ `Copy` ï¼Œä¸éœ€è¦åˆ†é…å†…å­˜æˆ–æŸç§å½¢å¼èµ„æºçš„ç±»å‹æ˜¯å¯ä»¥ `Copy` çš„**ã€‚å¦‚ä¸‹æ˜¯ä¸€äº› `Copy` çš„ç±»å‹ï¼š

-   æ‰€æœ‰æ•´æ•°ç±»å‹ï¼Œæ¯”å¦‚ `u32`ã€‚
-   å¸ƒå°”ç±»å‹ï¼Œ`bool`ï¼Œå®ƒçš„å€¼æ˜¯ `true` å’Œ `false`ã€‚
-   æ‰€æœ‰æµ®ç‚¹æ•°ç±»å‹ï¼Œæ¯”å¦‚ `f64`ã€‚
-   å­—ç¬¦ç±»å‹ï¼Œ`char`ã€‚
-   å…ƒç»„ï¼Œå½“ä¸”ä»…å½“å…¶åŒ…å«çš„ç±»å‹ä¹Ÿéƒ½æ˜¯ `Copy` çš„æ—¶å€™ã€‚æ¯”å¦‚ï¼Œ`(i32, i32)` æ˜¯ `Copy` çš„ï¼Œä½† `(i32, String)` å°±ä¸æ˜¯ã€‚
-   å¼•ç”¨ç±»å‹

#### å‡½æ•°ä¼ å€¼ä¸è¿”å›

å°†å€¼ä¼ é€’ç»™å‡½æ•°ï¼Œä¸€æ ·ä¼šå‘ç”Ÿ `ç§»åŠ¨` æˆ–è€… `å¤åˆ¶`ï¼Œå°±è·Ÿ `let` è¯­å¥ä¸€æ ·ã€‚

```rust
fn main() {
    let s = String::from("hello");  // s è¿›å…¥ä½œç”¨åŸŸ

    takes_ownership(s);             // s çš„å€¼ç§»åŠ¨åˆ°å‡½æ•°é‡Œ ...
                                    // ... æ‰€ä»¥åˆ°è¿™é‡Œä¸å†æœ‰æ•ˆ

    let x = 5;                      // x è¿›å…¥ä½œç”¨åŸŸ

    makes_copy(x);                  // x åº”è¯¥ç§»åŠ¨å‡½æ•°é‡Œï¼Œ
                                    // ä½† i32 æ˜¯ Copy çš„ï¼Œæ‰€ä»¥åœ¨åé¢å¯ç»§ç»­ä½¿ç”¨ x

} // è¿™é‡Œ, x å…ˆç§»å‡ºäº†ä½œç”¨åŸŸï¼Œç„¶åæ˜¯ sã€‚ä½†å› ä¸º s çš„å€¼å·²è¢«ç§»èµ°ï¼Œ
  // æ‰€ä»¥ä¸ä¼šæœ‰ç‰¹æ®Šæ“ä½œ

fn takes_ownership(some_string: String) { // some_string è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_string);
} // è¿™é‡Œï¼Œsome_string ç§»å‡ºä½œç”¨åŸŸå¹¶è°ƒç”¨ `drop` æ–¹æ³•ã€‚å ç”¨çš„å†…å­˜è¢«é‡Šæ”¾

fn makes_copy(some_integer: i32) { // some_integer è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_integer);
} // è¿™é‡Œï¼Œsome_integer ç§»å‡ºä½œç”¨åŸŸã€‚ä¸ä¼šæœ‰ç‰¹æ®Šæ“ä½œ
```

åŒæ ·çš„ï¼Œå‡½æ•°è¿”å›å€¼ä¹Ÿæœ‰æ‰€æœ‰æƒï¼Œä¾‹å¦‚:

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership å°†è¿”å›å€¼
                                        // ç§»ç»™ s1

    let s2 = String::from("hello");     // s2 è¿›å…¥ä½œç”¨åŸŸ

    let s3 = takes_and_gives_back(s2);  // s2 è¢«ç§»åŠ¨åˆ°
                                        // takes_and_gives_back ä¸­,
                                        // å®ƒä¹Ÿå°†è¿”å›å€¼ç§»ç»™ s3
} // è¿™é‡Œ, s3 ç§»å‡ºä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒã€‚s2 ä¹Ÿç§»å‡ºä½œç”¨åŸŸï¼Œä½†å·²è¢«ç§»èµ°ï¼Œ
  // æ‰€ä»¥ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿã€‚s1 ç§»å‡ºä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ

fn gives_ownership() -> String {             // gives_ownership å°†è¿”å›å€¼ç§»åŠ¨ç»™
                                             // è°ƒç”¨å®ƒçš„å‡½æ•°

    let some_string = String::from("hello"); // some_string è¿›å…¥ä½œç”¨åŸŸ.

    some_string                              // è¿”å› some_string å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
}

// takes_and_gives_back å°†ä¼ å…¥å­—ç¬¦ä¸²å¹¶è¿”å›è¯¥å€¼
fn takes_and_gives_back(a_string: String) -> String { // a_string è¿›å…¥ä½œç”¨åŸŸ

    a_string  // è¿”å› a_string å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
}
```

### å¼•ç”¨ä¸å€Ÿç”¨

å¦‚æœä»…ä»…ä½¿ç”¨å˜é‡çš„æŒ‡é’ˆæˆ–è€…å¼•ç”¨ï¼Œè€Œéè·å¾—æ‰€æœ‰æƒï¼Œå¯ä»¥é€šè¿‡ `å€Ÿç”¨(Borrowing)` ï¼Œ**è·å–å˜é‡çš„å¼•ç”¨ï¼Œç§°ä¹‹ä¸ºå€Ÿç”¨(borrowing)**ã€‚

#### å¼•ç”¨ä¸è§£å¼•ç”¨

```rust
fn main() {
    let x = 5;
    let y = &x; // è·å–æŒ‡å‘xçš„å¼•ç”¨

    assert_eq!(5, x);
    assert_eq!(5, *y); // é€šè¿‡ `*` è§£å¼•ç”¨ï¼Œå¾—åˆ°yæ‰€æŒ‡å‘çš„æ•°æ® 
}
```

#### ä¸å¯å˜å¼•ç”¨

ä¸‹é¢çš„ä»£ç ï¼Œæˆ‘ä»¬ç”¨ `s1` çš„å¼•ç”¨ä½œä¸ºå‚æ•°ä¼ é€’ç»™ `calculate_length` å‡½æ•°ï¼Œè€Œä¸æ˜¯æŠŠ `s1` çš„æ‰€æœ‰æƒè½¬ç§»ç»™è¯¥å‡½æ•°ï¼š

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
output:
The length of 'hello' is 5.
```

å˜åŒ–è¿‡ç¨‹ï¼š

![&String s pointing at String s1](https://s2.loli.net/2022/03/13/bnqGQHhCDvy2pF7.jpg)

#### å¯å˜å¼•ç”¨

é€šè¿‡ `mut` å…³é”®å­—ï¼Œå¯ä»¥æ“ä½œå¼•ç”¨æ‰€æŒ‡å‘çš„æ•°æ®

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
    println!("s is :{}", s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
output:
s is :hello, world
```

å®ƒæœ‰ä¸€ä¸ªå¾ˆå¤§çš„é™åˆ¶ï¼š **åŒä¸€ä½œç”¨åŸŸï¼Œç‰¹å®šæ•°æ®åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨**ï¼š

```rust
#![allow(unused)]
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
}
output:
error[E0499]: cannot borrow `s` as mutable more than once at a time
  --> src/main.rs:10:14
   |
9  |     let r1 = &mut s;
   |              ------ first mutable borrow occurs here
10 |     let r2 = &mut s;
   |              ^^^^^^ second mutable borrow occurs here
11 | 
12 |     println!("{}, {}", r1, r2);
   |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `hello_world` due to previous error
```

##### å¯å˜å¼•ç”¨ä¸ä¸å¯å˜å¼•ç”¨ä¸èƒ½åŒæ—¶å­˜åœ¨

```rust
#![allow(unused)]
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // æ²¡é—®é¢˜
    let r2 = &s; // æ²¡é—®é¢˜
    let r3 = &mut s; // å¤§é—®é¢˜

    println!("{}, {}, and {}", r1, r2, r3);
}
```

#### æ‚¬å‚å¼•ç”¨(Dangling References)

æ‚¬å‚å¼•ç”¨ä¹Ÿå«åšæ‚¬å‚æŒ‡é’ˆï¼Œæ„æ€ä¸ºæŒ‡é’ˆæŒ‡å‘æŸä¸ªå€¼åï¼Œè¿™ä¸ªå€¼è¢«é‡Šæ”¾æ‰äº†ï¼Œè€ŒæŒ‡é’ˆä»ç„¶å­˜åœ¨ï¼Œå…¶æŒ‡å‘çš„å†…å­˜å¯èƒ½ä¸å­˜åœ¨ä»»ä½•å€¼æˆ–å·²è¢«å…¶å®ƒå˜é‡é‡æ–°ä½¿ç”¨ã€‚

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
output:
error[E0106]: missing lifetime specifier
  --> src/main.rs:11:16
   |
11 | fn dangle() -> &String {
   |                ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
   |
11 | fn dangle() -> &'static String {
   |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `hello_world` due to previous error
```

#### å€Ÿç”¨è§„åˆ™æ€»ç»“

æ€»çš„æ¥è¯´ï¼Œå€Ÿç”¨è§„åˆ™å¦‚ä¸‹ï¼š

-   åŒä¸€æ—¶åˆ»ï¼Œä½ åªèƒ½æ‹¥æœ‰è¦ä¹ˆä¸€ä¸ªå¯å˜å¼•ç”¨, è¦ä¹ˆä»»æ„å¤šä¸ªä¸å¯å˜å¼•ç”¨
-   å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„
